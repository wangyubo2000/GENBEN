{"task_id": "MGA_1", "task_recommend": "This module implements a 4-bit ripple counter using the dff flip-flop described above. Each flip-flop captures the inverted output of the previous stage's output, creating a ripple effect through the counter.", "images": ["MGA_1\\img_99.png"], "verilog": "module dff (\n    input d,\n    input clk,\n    input rstn,\n    output reg q,\n    output qn\n);\nalways @(posedge clk or negedge rstn) begin\n    if (!rstn)\n        q <= 0;\n    else\n        q <= d;\nend\nassign qn = ~q;\nendmodule\n\nmodule ripple (\n    input clk,\n    input rstn,\n    output [3:0] out\n);\nwire q0, qn0;\nwire q1, qn1;\nwire q2, qn2;\nwire q3, qn3;\n\ndff dff0 (.d(qn0), .clk(clk), .rstn(rstn), .q(q0), .qn(qn0));\ndff dff1 (.d(qn1), .clk(q0), .rstn(rstn), .q(q1), .qn(qn1));\ndff dff2 (.d(qn2), .clk(q1), .rstn(rstn), .q(q2), .qn(qn2));\ndff dff3 (.d(qn3), .clk(q2), .rstn(rstn), .q(q3), .qn(qn3));\n\nassign out = {qn3, qn2, qn1, qn0};\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk;\n    reg rstn;\n    wire [3:0] out;\n\n    // Instantiate the ripple counter (Device Under Test)\n    top r0 (\n        .clk(clk), \n        .rstn(rstn), \n        .out(out)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units, creating a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 0;   // Initialize clock\n        rstn = 0;  // Assert reset\n\n        // De-assert reset after 4 clock cycles\n        repeat (4) @(posedge clk);\n        rstn <= 1;\n\n        // Run for 25 clock cycles before finishing simulation\n        repeat (25) @(posedge clk);\n        $finish;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
