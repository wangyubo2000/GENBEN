{"task_id": "DA_1", "task_recommend": "Revise the testbench of the following model so that it only prints a line if the result in `res` does not agree with the expected result `r`.\n```verliog\nmodule alu (op, res, d1, d2, clk);\n\toutput [3:0] res;\n\tinput [3:0] op;\n\tinput [11:0] d1, d2;\n\tinput clk;\n\treg [11:0] result;\n\tassign #1 res = result;\n\t\n\talways @(posedge clk) begin\n\t\tcase (op)\n\t\t1:\tresult = d1 + d2;\n\t\t2:\tresult = d1 - d2;\n\t\t3:\tresult = -d1;\n\t\t4:\tresult = d1 & d2;\n\t\t5:\tresult = ~d1;\n\t\t6:\tresult = d1 | d2;\n\t\tendcase\n\tend\n\nendmodule\n\nmodule top;\n\twire [11:0] res, d1, d2;\n\twire [3:0] op;\n\treg clk;\n\n\talu a (op, res, d1, d2, clk);\n\ttestbench tb (op, res, d1, d2, clk);\n\t\n\tinitial begin\n\t\tclk = 0;\n\t\tforever \n\t\t\t#10 clk = ~clk;\n\tend\n\nendmodule\n\nmodule testbench (op, res, d1, d2, clk);\n\tinput [11:0] res;\n\toutput [3:0] op;\n\toutput [11:0] d1, d2;\n\tinput clk;\n\treg [3:0] op;\n\treg [11:0] d1, d2;\n\tinteger opcnt, errcnt;\n\n\tinitial begin\n\t\topcnt = 0; errcnt = 0;\n\t\tdoadd('h111, 'h111, 'h222);\n\t\t$display(\"%0d operations, %0d errors\", opcnt, errcnt);\n\t\t$finish;\n\tend\n\n\ttask doadd;\n\t\tinput [11:0] a, b, r;\n\t\tbegin\n\t\t\top = 1; d1 = a; d2 = b;\n\t\t@(posedge clk) ;\n\t\t// Rewrite\n\t\t#1\t$strobe (\"op %0d: %h + %h = %h\", opcnt, d1, d2, res);\n\t\t//\n\t\tend\n```", "verilog": "\t#2\tif (res !== r) begin\t// or @(negedge clk)\n\t\t\t$display(\"error: op %0d  %h != %h\", opcnt, res, r);\n\t\t\terrcnt = errcnt + 1;\n\t\tend"}
{"task_id": "GA_1", "task_recommend": "The module zero3 below implements a 3-stage pipeline. Each stage is a single bit, and there is a single bit as input. Modify this model to use the following pipe stage. Assume the clock period is 10. Click Answer to see a sample solution.", "verilog": "module zero3 (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg s1, s2, s3;\n\n\tassign out = s1==0 & s2==0 & s3==0;\n\n\tinitial begin\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\ts3 = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\ts1 <= in;\n\t\ts2 <= s1;\n\t\ts3 <= s2;\n\tend\nendmodule\n\n\n# module_top\nmodule top (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg s1, s2, s3;\n\n\tassign out = s1==0 & s2==0 & s3==0;\n\n\tinitial begin\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\ts3 = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\ts1 <= in;\n\t\ts2 <= s1;\n\t\ts3 <= s2;\n\tend\nendmodule", "test": "module tb();\n\twire out;\n\treg in, clk;\n\n\ttop z3 (out, in, clk);\n\n\tinitial begin\n\t\tin = 0;\n\t\tclk = 0;\n\t\tforever #5 clk = ~clk;\n\tend\n\n\tinitial begin\n\t\t$monitor($stime,,\"clk: %b  in: %b  out: %b\", clk, in, out);\n\t\trepeat (2) @(posedge clk);\n\t\tin <= 1;\n\t\trepeat (2) @(posedge clk);\n\t\tin <= 0;\n\t\trepeat (4) @(posedge clk) ;\n\t\tin <= 1;\n\t\trepeat (3) @(posedge clk) in <= ~in;\n\t\t@(posedge clk) in <= 0;\n\t\trepeat (4) @(posedge clk) ;\n\t#1\t$finish;\n\t\n\tend\nendmodule"}
{"task_id": "MDA_1", "task_recommend": "Shift register circuit is implemented by blocking assignment\n\nThe following code incorrectly uses the blocking assignment to describe the shift register. How can I modify the shift register so that the code can complete the above image.\nmy code:\n```\nmodule pipeb1 (q3, d, clk);\n    output [7:0] q3;\n    input [7:0] d;\n    input clk;\n    reg [7:0] q3, q2, q1;\n    always @(posedge clk)\n        begin\n          q1 = d;\n          q2 = q1;\n          q3 = q2;\n        end\n endmodule\n```", "images": ["MDA_1\\img_60.png"], "verilog": "module pipen1 (q3, d, clk); \n    output [7:0] q3; \n    input [7:0] d; \n    input clk; \n    reg [7:0] q3, q2, q1; \n    always @(posedge clk) begin \n        q1 <= d; \n        q2 <= q1; \n        q3 <= q2; \n    end \n endmodule "}
{"task_id": "MGA_1", "task_recommend": "This module implements a 4-bit ripple counter using the dff flip-flop described above. Each flip-flop captures the inverted output of the previous stage's output, creating a ripple effect through the counter.", "images": ["MGA_1\\img_99.png"], "verilog": "module dff (\n    input d,\n    input clk,\n    input rstn,\n    output reg q,\n    output qn\n);\nalways @(posedge clk or negedge rstn) begin\n    if (!rstn)\n        q <= 0;\n    else\n        q <= d;\nend\nassign qn = ~q;\nendmodule\n\nmodule ripple (\n    input clk,\n    input rstn,\n    output [3:0] out\n);\nwire q0, qn0;\nwire q1, qn1;\nwire q2, qn2;\nwire q3, qn3;\n\ndff dff0 (.d(qn0), .clk(clk), .rstn(rstn), .q(q0), .qn(qn0));\ndff dff1 (.d(qn1), .clk(q0), .rstn(rstn), .q(q1), .qn(qn1));\ndff dff2 (.d(qn2), .clk(q1), .rstn(rstn), .q(q2), .qn(qn2));\ndff dff3 (.d(qn3), .clk(q2), .rstn(rstn), .q(q3), .qn(qn3));\n\nassign out = {qn3, qn2, qn1, qn0};\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk;\n    reg rstn;\n    wire [3:0] out;\n\n    // Instantiate the ripple counter (Device Under Test)\n    top r0 (\n        .clk(clk), \n        .rstn(rstn), \n        .out(out)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units, creating a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 0;   // Initialize clock\n        rstn = 0;  // Assert reset\n\n        // De-assert reset after 4 clock cycles\n        repeat (4) @(posedge clk);\n        rstn <= 1;\n\n        // Run for 25 clock cycles before finishing simulation\n        repeat (25) @(posedge clk);\n        $finish;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
