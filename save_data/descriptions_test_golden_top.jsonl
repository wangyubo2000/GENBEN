{"task_id": "GA_1", "task_recommend": "The module zero3 below implements a 3-stage pipeline. Each stage is a single bit, and there is a single bit as input. Modify this model to use the following pipe stage. Assume the clock period is 10. Click Answer to see a sample solution.", "verilog": "module zero3 (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg s1, s2, s3;\n\n\tassign out = s1==0 & s2==0 & s3==0;\n\n\tinitial begin\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\ts3 = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\ts1 <= in;\n\t\ts2 <= s1;\n\t\ts3 <= s2;\n\tend\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb();\n    wire out;\n    reg in, clk;\n\n\n    top z3 (.out(out), .in(in), .clk(clk));\n\n    initial begin\n        in = 0;\n        clk = 0;\n        forever #5 clk = ~clk;\n    end\n\n    initial begin\n        $dumpfile(\"test.vcd\");\n        $dumpvars(0, tb);\n\n        $monitor($stime, \" clk: %b  in: %b  out: %b\", clk, in, out);\n        repeat (2) @(posedge clk);\n        in <= 1;\n        repeat (2) @(posedge clk);\n        in <= 0;\n        repeat (4) @(posedge clk);\n        in <= 1;\n        repeat (3) @(posedge clk) in <= ~in;\n        @(posedge clk) in <= 0;\n        repeat (4) @(posedge clk);\n        #1 $finish;\n    end\nendmodule\n"}
{"task_id": "GA_10", "task_recommend": "Use the 4-to-1 multiplexer and the required logic gates to implement the following expression:\nL = A·B' + A·C' + B'C\n\nInputs:\n- input A\n- input B\n- input C\n\nOutput:\n- output wire L", "verilog": "module data_sel(\n   input             S0     ,\n   input             S1     ,\n   input             D0     ,\n   input             D1     ,\n   input             D2     ,\n   input             D3     ,\n\n   output wire        Y\n);\n\nassign Y = ~S1 & (~S0&D0 | S0&D1) | S1&(~S0&D2 | S0&D3);\n\nendmodule\n\nmodule sel_exp(\n   input             A     ,\n   input             B     ,\n   input             C     ,\n   \n   output wire       L            \n);\n    data_sel luoji(\n        .S1(A),\n        .S0(B),\n        .D0(1'b0),\n        .D1(C),\n        .D2(~C),\n        .D3(1'b1),\n        .Y(L)\n    );\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  A;\n    reg  B;\n    reg  C;\n    wire L;\n\n    // Initialization Block\n    initial begin\n        A = 1'b0;\n        B = 1'b0;\n        C = 1'b0;\n        #200\n        $finish;  // End simulation after 200 ns\n    end\n\n    // Random Stimulus Generation\n    always #10 A <= {$random} % 2;  // Random value for A (1-bit range)\n    always #10 B <= {$random} % 2;  // Random value for B (1-bit range)\n    always #10 C <= {$random} % 2;  // Random value for C (1-bit range)\n\n    // DUT (Device Under Test) Instantiation\n    top sel_exp_inst (\n        .A (A),\n        .B (B),\n        .C (C),\n        .L (L)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_11", "task_recommend": "Implement an 8-depth, 4-bit wide ROM with data initialized to 0, 2, 4, 6, 8, 10, 12, 14. The data corresponding to the input address addr can be output through the data signal. \n#### Input Description:\n- clk: System clock\n- rst_n: Asynchronous reset signal, active low\n- addr: 8-bit wide unsigned number, input address to the ROM\n#### Output Description:\n- data: 4-bit wide unsigned number, data read from the ROM", "verilog": "module rom(\n\tinput          clk,\n\tinput          rst_n,\n\tinput  [7:0]   addr,\n\t\n\toutput [3:0]   data\n);\n \nreg [3:0]   rom  [7:0];\nreg [3:0]   data_reg;\n \ninteger i;\ninitial begin\n\tfor (i=0;i<8;i=i+1) begin\n\t\trom[i] = i*2;\n\tend\nend\n \nalways @(*) begin\n\tif (!rst_n) begin\n\t\tdata_reg <= 4'd0;\n\tend\n\telse begin\n\t\tdata_reg <= rom[addr];\n\tend\nend\nassign data = data_reg;\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg        clk;\n    reg        rst_n;\n    reg  [7:0] addr;\n    wire [3:0] data;\n\n    // Initialization Block\n    initial begin\n        clk   = 1'b1;\n        rst_n = 1'b0;\n        #20\n        rst_n = 1'b1;  // Release reset after 20 ns\n        #200\n        $finish;  // End simulation after 200 ns\n    end\n\n    // Clock Generation\n    always #5 clk = ~clk;\n\n    // Random Address Generation\n    always #10 addr <= {$random} % 8;  // Random value for addr within 3-bit range (0-7)\n\n    // DUT (Device Under Test) Instantiation\n    top inst_rom (\n        .clk   (clk),\n        .rst_n (rst_n),\n        .addr  (addr),\n        .data  (data)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_12", "task_recommend": "Write a program to detect the rising and falling edges of a 1-bit signal a. When a rising edge is detected, output the signal rise. When a falling edge is detected, output the signal down. The rise and down signals should remain high for one clock cycle after the edge is detected, then return to low until the next edge is detected.\n\n#### Input Description:\n- clk: System clock signal\n- rst_n: Asynchronous reset signal, active low\n- a: 1-bit signal to be edge detected\n#### Output Description:\n- rise: Signal goes high for one clock cycle when a rising edge of a is detected\n- down: Signal goes high for one clock cycle when a falling edge of a is detected", "verilog": "module edge_detect(\n\tinput         clk,\n\tinput         rst_n,\n\tinput         a,\n\t\n\toutput reg    rise,\n\toutput reg    down\n);\n \nreg       a_reg;\nwire      pulse;\n \nalways @(posedge clk or negedge rst_n) begin\n\tif (!rst_n) begin\n\t\ta_reg <= 1'b0;\n\tend\n\telse begin\n\t\ta_reg <= a;\n\tend\nend\nassign pulse = a ^ a_reg;\nalways @(posedge clk or negedge rst_n) begin\n\tif (!rst_n) begin\n\t\trise <= 1'b0;\n\t\tdown <= 1'b0;\n\tend\n\telse if (pulse && a) begin\n\t\trise <= 1'b1;\n\tend\n\telse if (pulse && ~a) begin\n\t\tdown <= 1'b1;\n\tend\n\telse begin\n\t\trise <= 1'b0;\n\t\tdown <= 1'b0;\t\t\n\tend\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  clk;\n    reg  rst_n;\n    reg  a;\n    wire rise;\n    wire down;\n\n    // Initialization Block\n    initial begin\n        clk = 1'b1;\n        rst_n = 1'b0;\n        a = 1'b0;\n        #20 rst_n = 1'b1;  // Release reset after 20 ns\n        #20 a = 1'b1;       // Apply test sequence\n        #20 a = 1'b0;\n        #30 a = 1'b1;\n        #40 a = 1'b0;\n        #20 a = 1'b1;\n        #20 a = 1'b0;\n        #20 $finish;        // End simulation after 200 ns\n    end\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Clock toggles every 5 ns\n\n    // DUT (Device Under Test) Instantiation\n    top inst_edge_detect (\n        .clk   (clk),\n        .rst_n (rst_n),\n        .a     (a),\n        .rise  (rise),\n        .down  (down)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_13", "task_recommend": "Design a frequency divider module in Verilog HDL that divides the input clock frequency by an odd factor and maintains a 50% duty cycle. The module uses separate counters to track both the rising edge and falling edge of the input clock. The output clock (clk_out) is generated by combining the output signals of the rising and falling edge counters.\n###Counters (cnt1 and cnt2):\nThese are 3-bit counters that reset when they reach 4 (cnt1 == 4 and cnt2 == 4), effectively counting 5 clock edges (0 to 4).\n###Intermediate Clocks (clk1 and clk2):\nclk1 is toggled high for the first two counts (cnt1 < 2) on the positive edge of clk and low otherwise.\nclk2 is toggled similarly on the negative edge of clk.\n###Output Clock (clk_out):\nThe output clock is generated by OR'ing clk1 and clk2 to produce a signal with an odd division factor and 50% duty cycle.", "verilog": "module freq_div_odd (input        clk,\n\tinput        rst,\n\toutput wire  clk_out\n\t);\nreg  [2:0]   cnt1;\nreg  [2:0]   cnt2;\nreg          clk1;\nreg          clk2;\n \nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tcnt1 <= 'd0;\n\tend\n\telse if (cnt1 == 'd4) begin\n\t\tcnt1 <= 'd0;\n\tend\n\telse begin\n\t\tcnt1 <= cnt1 + 'd1;\n\tend\nend\n \nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tclk1 <= 'd0;\n\tend\n\telse if (cnt1 < 'd2) begin\n\t\tclk1 <= 'd1;\n\tend\n\telse begin\n\t\tclk1 <= 'd0;\n\tend\nend\n \nalways @(negedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tcnt2 <= 'd0;\n\tend\n\telse if (cnt2 == 'd4) begin\n\t\tcnt2 <= 'd0;\n\tend\n\telse begin\n\t\tcnt2 <= cnt2 + 'd1;\n\tend\nend\n \nalways @(negedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tclk2 <= 'd0;\n\tend\n\telse if (cnt2 < 'd2) begin\n\t\tclk2 <= 'd1;\n\tend\n\telse begin\n\t\tclk2 <= 'd0;\n\tend\nend\n \nassign clk_out = clk1 | clk2;\n \nendmodule", "test": "`timescale 10ps / 1ps\n\nmodule tb;\n\n    // Signal Declarations\n    reg   clk;\n    reg   rst;\n    wire  clk_out;\n\n    // Initialization Block\n    initial begin\n        clk = 1'b0;    // Initialize clock to 0\n        rst = 1'b1;    // Assert reset\n        #20 rst = 1'b0; // Deassert reset after 20 ps\n    end\n\n    // Clock Generation\n    always #10 clk = ~clk;  // Clock toggles every 10 ps (50 ps period)\n\n    // DUT (Device Under Test) Instantiation\n    top inst_freq_div_odd (\n        .clk(clk),\n        .rst(rst),\n        .clk_out(clk_out)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_14", "task_recommend": "Realize any decimal frequency division, taking 6.3 frequency division as an example. If the arbitrary decimal frequency division needs to be divided more finely, it can be divided into half-integer fractions and non-half-integer decimal frequency divisions. Because half-integers are also decimals, the design of arbitrary decimal frequency division is used here. method implementation.", "verilog": "module freq_div_decimal (input       clk,\n\tinput       rst,\n\toutput reg  clk_out\n\t);\nreg  [3:0]   cnt1;\nreg  [3:0]   cnt2;\n \nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tcnt1 <= 'd0;\n\tend\n\telse if ((cnt2 < 'd7) &&(cnt1 == 'd5)) begin\n\t\tcnt1 <= 'd0;\n\tend\n\telse if (cnt1 == 'd6) begin\n\t\tcnt1 <= 'd0;\n\tend\n\telse begin\n\t\tcnt1 <= cnt1 + 'd1;\n\tend\nend\nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tcnt2 <= 'd0;\n\tend\n\telse if ((cnt2 == 'd9) && (cnt1 == 'd6)) begin\n\t\tcnt2 <= 'd0;\n\tend\n\telse if ((cnt1 == 'd5) && (cnt2 < 'd7)) begin\n\t\tcnt2 <= cnt2 + 'd1;\n\tend\n\telse if (cnt1 == 'd6) begin\n\t\tcnt2 <= cnt2 + 'd1;\n\tend\n\telse begin\n\t\tcnt2 <= cnt2;\n\tend\nend\n \nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tclk_out <= 'd0;\n\tend\n\telse if ((cnt1 == 'd5) && (cnt2 < 'd7)) begin\n\t\tclk_out <= 'd1;\n\tend\n\telse if (cnt1 == 'd6) begin\n\t\tclk_out <= 'd1;\n\tend\n\telse begin\n\t\tclk_out <= 'd0;\n\tend\nend\nendmodule", "test": "module tb();\n \n\treg   clk;\n\treg   rst;\n\twire  clk_out;\n \n\tinitial begin\n\t\tclk = 'd0;\n\t\trst = 'd1;\n\t\t#20\n\t\trst = 'd0;\n\tend\n\talways #10 clk = ~clk;\n\ttop inst_freq_div_decimal (\n\t\t.clk(clk), \n\t\t.rst(rst), \n\t\t.clk_out(clk_out)\n\t);\n\t// VCD\n    initial begin $dumpfile(\"tb.vcd\");\n    $dumpvars(0);\n    end\nendmodule"}
{"task_id": "GA_15", "task_recommend": "Design a Verilog module called booth_multiple that implements Booth's multiplication algorithm for signed 4-bit binary numbers. Booth's algorithm is a multiplication algorithm that allows for efficient multiplication of signed binary numbers by reducing the number of arithmetic operations required.\nInputs:\n\nclk : Clock signal for synchronization.\nrst : Asynchronous reset signal.\nstart : Signal to initiate the multiplication process.\nX : A signed 4-bit input representing the multiplicand.\nY : A signed 4-bit input representing the multiplier.\nOutputs:\n\nZ : A signed 8-bit output representing the result of the multiplication of X and Y.\nvalid : A signal indicating that the multiplication is complete and the result is valid.", "verilog": "module booth_multiple(\n\tinput                     clk,\n\tinput                     rst,\n\tinput                     start,\n\tinput      signed [3:0]   X,\n\tinput      signed [3:0]   Y,\n\toutput reg signed [7:0]   Z,\n\toutput                    valid\n\t);\n \nparameter  IDLE      =  3'b001;\nparameter  CACULATE  =  3'b010;\nparameter  FINISH    =  3'b100;\nreg        [2:0]   state;\nreg        [2:0]   next_state;\nreg        [1:0]   q_reg;           //右移最后两位寄存 \nreg        [2:0]   cnt;             //右移次数计数信号  \n\n//状态机第一段，状态初始化，时序逻辑非阻塞赋值\nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tstate <= IDLE;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\tend\nend\n//状态机第二段，状态跳转，组合逻辑阻塞赋值\nalways @(*) begin\n\tnext_state = state;\n\tcase(state)\n\t\tIDLE: begin\n\t\t\tif (start) begin\n\t\t\t\tnext_state = CACULATE;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = IDLE;\n\t\t\tend\n\t\tend\n\t\tCACULATE: begin\n\t\t\tif (cnt == 'd3) begin\n\t\t\t\tnext_state = FINISH;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state = CACULATE;\n\t\t\tend\n\t\tend\n\t\tFINISH: begin\n\t\t\tnext_state = IDLE;\n\t\tend\n\tendcase\nend\n \n//状态机第三段，结果输出，时序逻辑非阻塞赋值\nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tcnt   <= 'd0;\n\t\tq_reg <= 'd0;\n\t\tZ     <= 'd0;\n\tend\n\telse begin\n\t\tcase(state)\n\t\t\tIDLE: begin\n\t\t\t\tcnt   <= 'd0;\n\t\t\t\tq_reg <= {Y[cnt],1'b0};\n\t\t\t\tZ     <= {4'b0000,Y};\n\t\t\tend\n\t\t\tCACULATE: begin\n\t\t\t\tcnt   <= cnt + 'd1;\n\t\t\t\tq_reg <= {Y[cnt+1],Y[cnt]};\n\t\t\t\tcase(q_reg)\n\t\t\t\t\t2'b00,2'b11: begin\n\t\t\t\t\t\tZ <= $signed(Z)>>>1;\n\t\t\t\t\tend\n\t\t\t\t\t2'b10: begin\n\t\t\t\t\t\tZ <= $signed({Z[7:4]-X,Z[3:0]})>>>1;\n\t\t\t\t\tend\n\t\t\t\t\t2'b01: begin\n\t\t\t\t\t\tZ <= $signed({Z[7:4]+X,Z[3:0]})>>>1;\t\t\t\t\t\t\n\t\t\t\t\tend\n\t\t\t\tendcase\n\t\t\tend\n\t\t\tFINISH: begin\n\t\t\t\tcnt   <= 'd0;\n\t\t\t\tq_reg <= 'd0;\n\t\t\t\tZ     <= Z;\t\t\t\t\n\t\t\tend\t\t\t\t\t\n\t\tendcase\n\tend\nend\nassign valid = (state==FINISH);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg                 clk;\n    reg                 rst;\n    reg                 start;\n    reg  signed [3:0]   X;\n    reg  signed [3:0]   Y;\n    wire signed [7:0]   Z;\n    wire                valid;\n\n    // Clock Generation\n    always #10 clk = ~clk;\n\n    // Initialization Block\n    initial begin\n        clk = 1'b0;\n        rst = 1'b1;\n        #20 rst = 1'b0;  // Deassert reset after 20 ns\n    end\n\n    // Stimulus Block\n    initial begin\n        #20;\n        X = 6;\n        Y = -4;\n        start = 1'b0;\n        #50;\n        start = 1'b1;    // Start multiplication\n        #20;\n        start = 1'b0;    // Stop after start pulse\n        #200;\n\n        X = 7;\n        Y = -5;\n        start = 1'b1;    // Start multiplication\n        #20;\n        start = 1'b0;    // Stop after start pulse\n        #200;\n\n        X = 7;\n        Y = 5;\n        start = 1'b1;    // Start multiplication\n        #20;\n        start = 1'b0;    // Stop after start pulse\n    end\n\n    // DUT (Device Under Test) Instantiation\n    top inst_booth_multiple (\n        .clk   (clk),\n        .rst   (rst),\n        .start (start),\n        .X     (X),\n        .Y     (Y),\n        .Z     (Z),\n        .valid (valid)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_16", "task_recommend": "Design a Verilog module named melay that implements a Mealy state machine. The state machine accepts a single-bit input Data_in, performs state transition on the rising edge of clock clk, and outputs a single-bit signal Data_out based on the current state and input. The reset signal rst resets the state machine to its initial state when it is high.", "verilog": "module melay(Data_in,Data_out,clk,rst);\ninput Data_in,clk,rst;\noutput reg Data_out;\nreg[2:0]current_state,next_state;\nParameter\ns0=3'b000,s1=3'b001,s11=3'b010,s110=3'b011,s10=3'b100,s101=3'b101;\nalways @ (posedge clk,posedge rst)\nbegin\n\tif(rst)\n\tcurrent_state<=s0;\n\telse\n\tcurrent_state<=next_state;\nend\nalways @(Data_in,current_state)\nbegin\n\tcase(current_state)\n\ts0:\n\t\tif(Data_in==0)\n\t\tnext_state<=s0;\n\t\telse\n\t\tnext_state<=s1;\n\ts1:\n\t\tif(Data_in==0)\n\t\tnext_state<=s10;\n\t\telse\n\t\tnext_state<=s11;\n\ts11:\n\t\tif(Data_in==0)\n\t\tnext_state<=s110;\n\t\telse\n\t\tnext_state<=s11;\n\ts110:\n\t\tif(Data_in==1)\n\t\tnext_state<=s101;\n\t\telse\n\t\tnext_state<=s0;\n\ts10:\n\t\tif(Data_in==1)\n\t\tnext_state<=s101;\n\t\telse\n\t\tnext_state<=s0;s101:\n\t\tif(Data_in==1)\n\t\tnext_state<=s11;\n\t\telse\n\t\tnext_state<=s10;\ndefault:next_state<=s0;\nendcase\nend\nalways @(posedge clk)\nbegin\n\tcase(current_state)\n\t\ts0:if(Data_in==1 || Data_in==0)\n\t\t\tData_out<=0;\n\t\ts1:if(Data_in==1 || Data_in==0 )\n\t\t\tData_out<=0;\n\t\ts11:\n\t\t\tif(Data_in==1)\n\t\t\tData_out<=0;\n\t\t\telse\n\t\t\tData_out<=1;\n\t\ts110:if(Data_in==1 || Data_in==0)\n\t\t\tData_out<=0;\n\t\ts101:if(Data_in==1 || Data_in==0)\n\t\t\tData_out<=0;\n\t\ts10:\n\t\t\tif(Data_in==1)\n\t\t\tData_out<=1;\n\t\t\telse\n\t\t\t\tData_out<=0;\ndefault:Data_out<=0;\nendcase\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg Data_in_tb, clk_tb, rst_tb;\n    wire Data_out_tb;\n\n    // Instantiate the DUT (Device Under Test)\n    melay DUT (\n        .Data_in(Data_in_tb),\n        .Data_out(Data_out_tb),\n        .clk(clk_tb),\n        .rst(rst_tb)\n    );\n\n    // Clock Generation\n    always begin\n        clk_tb = 1;\n        #10;\n        clk_tb = 0;\n        #10;\n    end\n\n    // Task to Initialize Signals\n    task initialize;\n    begin\n        Data_in_tb = 0;\n        rst_tb = 0;\n    end\n    endtask\n\n    // Task to Reset the Design\n    task rst(input a);\n    begin\n        @(negedge clk_tb)\n        rst_tb = 1;\n        @(negedge clk_tb)\n        rst_tb = 0;\n    end\n    endtask\n\n    // Task to Provide Data Input\n    task Din(input b);\n    begin\n        @(negedge clk_tb)\n        Data_in_tb = b;\n    end\n    endtask\n\n    // Initial Block to Apply Stimulus\n    initial begin\n        initialize;\n        rst(1);\n        Din(1);\n        Din(0);\n        Din(1);\n        rst(0);\n        Din(1);\n        Din(1);\n        Din(0);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GA_17", "task_recommend": "Design a Verilog module named moore that implements a simple Mealy state machine. The state machine accepts a single-bit input Data_in, performs state transition on the rising edge of clock clk, and outputs a single-bit signal Data_out according to the current state. The reset signal rst resets the state machine to its initial state when it is high.\nModule Description:\n###Inputs:\nData_in: Serial input data stream.\nclk: Clock input signal for synchronization.\nrst: Asynchronous reset signal to initialize the state machine.\n###Output:\nData_out: Output signal that becomes 1 when specific patterns are detected.\n###State Machine Description:\nThe Moore state machine has six states:\nIdle (3'b000): The initial state.\ns1 (3'b001): State reached after detecting the first '1'.\ns11 (3'b010): State reached after detecting the sequence \"11\".\ns110 (3'b011): State reached after detecting the sequence \"110\".\ns10 (3'b100): State reached after detecting the sequence \"10\".\ns101 (3'b101): State reached after detecting the sequence \"101\".\nThe state transitions depend on the value of Data_in and the current state.\nThe output Data_out is 1 when the state is s110 or s101.", "verilog": "module moore(Data_in,Data_out,clk,rst);\ninput Data_in,clk,rst;\noutput Data_out;\nreg[2:0]current_state,next_state;\nparameter Idle=3'b000,s1=3'b001,s11=3'b010,s110=3'b011,s10=3'b100,s101=3'b101;\nalways @ (posedge clk,posedge rst)\nbegin\nif(rst)\n    current_state <=Idle;\n    else\n    current_state<=next_state;\nend\n    always @(Data_in,current_state)\n    begin\n    case(current_state)\n        Idle:\n            if(Data_in==0)\n                next_state<=Idle;\n            else\n                next_state<=s1;\n        s1:\n            if(Data_in==1)\n                next_state<=s11;\n            else\n                next_state<=s10;\n        s11:\n            if(Data_in==0)\n                next_state<=s110;\n            else\n         \t    next_state<=s11;\n        s110:\n             if(Data_in==1)\n            \t   next_state<=s101;\n              else\n                next_state<=Idle;\n        s10:\n             if(Data_in==1)\n \t             next_state<=s101;\n             else\n                 next_state<=Idle;\n        s101:\n             if(Data_in==1)\n                next_state<=s11;\n             else\n                next_state<=s10;\n    default:next_state<=Idle;\n    endcase\nend\nassign Data_out=(current_state==s101 | current_state==s110)?1'b1:1'b0;\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg Data_in_tb, clk_tb, rst_tb;\n    wire Data_out_tb;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .Data_in(Data_in_tb),\n        .Data_out(Data_out_tb),\n        .clk(clk_tb),\n        .rst(rst_tb)\n    );\n\n    // Clock Generation\n    always begin\n        clk_tb = 1;\n        #10;\n        clk_tb = 0;\n        #10;\n    end\n\n    // Task to Initialize Signals\n    task initialize;\n    begin\n        Data_in_tb = 0;\n        rst_tb = 0;\n    end\n    endtask\n\n    // Task to Reset the Design\n    task rst(input a);\n    begin\n        @(negedge clk_tb)\n        rst_tb = 1;\n        @(negedge clk_tb)\n        rst_tb = 0;\n    end\n    endtask\n\n    // Task to Provide Data Input\n    task Din(input b);\n    begin\n        @(negedge clk_tb)\n        Data_in_tb = b;\n    end\n    endtask\n\n    // Initial Block to Apply Stimulus\n    initial begin\n        initialize;\n        rst(1);\n        Din(1);\n        Din(0);\n        Din(1);\n        rst(1);\n        Din(1);\n        Din(1);\n        Din(0);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_18", "task_recommend": "A 2-to-1 multiplexer (`mux_2x1`)  uses an inverted select signal (`sel_n`) to control which input, `a` or `b`, is forwarded to the output `out` based on the value of `sel`.", "verilog": "module mux_2x1 ( input a, b, sel,\n                 output out);\n    wire sel_n;\n    wire out_0;\n    wire out_1;\n\n    not (sel_n, sel);\n    and (out_0, a, sel);\n    and (out_1, b, sel_n);\n    or (out, out_0, out_1);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, sel;\n    wire out;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .sel(sel), \n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b, sel} = 3'b000;  // Initialize inputs to 0\n        $monitor(\"T=%t a=%b b=%b sel=%b out=%b\", $time, a, b, sel, out);\n\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random;\n            b = $random;\n            sel = $random;\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GA_19", "task_recommend": "Design a Verilog module named Comparater_n_bit (n=32)that implements a comparator with configurable bit width. The comparator accepts two n-bit input signals a and b and compares their magnitudes. Depending on the comparison results, the output signals l, e, and h represent a less than b, a equal to b, and a greater than b, respectively.", "verilog": "module Comparater_n_bit(a, b, l, e, h);\n    parameter n = 32;  // Default width of the input signals\n    input [n-1:0] a;\n    input [n-1:0] b;\n    output reg l = 0, e = 0, h = 0;  // Outputs initialized to 0\n\n    always @(a, b) begin\n        if (a > b) begin\n            l = 0; e = 0; h = 1;\n        end\n        else if (a < b) begin\n            l = 1; e = 0; h = 0;\n        end\n        else begin\n            l = 0; e = 1; h = 0;\n        end\n    end\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg [31:0] a;\n    reg [31:0] b;\n    wire l, e, h;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .a(a),\n        .b(b),\n        .l(l),\n        .e(e),\n        .h(h)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        a = 32'd22;  b = 32'd200;\n        #10 a = 32'd233; b = 32'd200;\n        #10 a = 32'd888; b = 32'd888;\n        #10 a = 32'd123; b = 32'd234;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GA_2", "task_recommend": "Single-port RAMs have **address lines** that are used to select the memory location to be accessed. The number of address lines determines the maximum number of memory locations that the RAM can hold. Data lines are used to carry the actual data to be read from or written to the memory location. Control signals, such as read enable (read request) and write enable (write request), are used to initiate specific memory operations.\nParameters:\nADDR_WIDTH: The width of the address bus (default is 4 bits), which determines the number of addressable locations in the memory.\nDATA_WIDTH: The width of the data bus (default is 32 bits), which determines the size of each data word.\nDEPTH: The depth of the memory (default is 16), representing the total number of data words that the RAM can hold.\nInputs:\nclk: Clock input for synchronizing read and write operations.\naddr: Address input (ADDR_WIDTH bits) to select the memory location.\ncs: Chip select input. The RAM is enabled when cs is high.\nwe: Write enable input. When we is high, a write operation is performed.\noe: Output enable input. When oe is high, data is driven onto the output bus during a read operation.", "verilog": "module single_port_sync_ram\n# (\n    parameter ADDR_WIDTH = 4,\n    parameter DATA_WIDTH = 32,\n    parameter DEPTH = 16\n)\n(\n    input                 clk,\n    input [ADDR_WIDTH-1:0] addr,\n    inout [DATA_WIDTH-1:0] data,\n    input                 cs,\n    input                 we,\n    input                 oe\n);\n\n    reg [DATA_WIDTH-1:0] tmp_data;\n    reg [DATA_WIDTH-1:0] mem [DEPTH];\n\n    always @ (posedge clk) begin\n        if (cs & we)\n            mem[addr] <= data;\n    end\n\n    always @ (posedge clk) begin\n        if (cs & !we)\n            tmp_data <= mem[addr];\n    end\n\n    assign data = cs & oe & !we ? tmp_data : 'hz;\n\nendmodule", "test": "module tb();\n    parameter ADDR_WIDTH = 4;\n    parameter DATA_WIDTH = 16;\n    parameter DEPTH = 16;\n\n    reg                 clk;\n    reg                 cs;\n    reg                 we;\n    reg                 oe;\n    reg [ADDR_WIDTH-1:0] addr;\n    wire [DATA_WIDTH-1:0] data;\n    reg [DATA_WIDTH-1:0] tb_data;\n\n    top #(.DATA_WIDTH(DATA_WIDTH)) u0 (\n        .clk(clk),\n        .addr(addr),\n        .data(data),\n        .cs(cs),\n        .we(we),\n        .oe(oe)\n    );\n\n    always #10 clk = ~clk;\n\n    assign data = !oe ? tb_data : 'hz;\n\n    initial begin\n        {clk, cs, we, addr, tb_data, oe} <= 0;\n\n        repeat (2) @ (posedge clk);\n\n        for (integer i = 0; i < 2**ADDR_WIDTH; i = i + 1) begin\n            repeat (1) @ (posedge clk) addr <= i; we <= 1; cs <= 1; oe <= 0; tb_data <= $random;\n        end\n\n        for (integer i = 0; i < 2**ADDR_WIDTH; i = i + 1) begin\n            repeat (1) @ (posedge clk) addr <= i; we <= 0; cs <= 1; oe <= 1;\n        end\n\n        #20 $finish;\n    end\n\nendmodule"}
{"task_id": "GA_20", "task_recommend": "In digital circuit design, it is common to encapsulate functionality into reusable modules or functions, which can then be instantiated in a main module as needed to increase code reusability and design hierarchy. Implement a function to swap the nibbles of a 4-bit input and then use it to create a module that performs this operation on two separate 4-bit inputs. The outputs should be the swapped results of the inputs.\n\n#### Signal Description:\nInputs:\n- clk: System clock\n- rst_n: Active-low reset signal\n- a, b: 4-bit unsigned inputs\n\nOutputs:\n- c, d: 4-bit unsigned outputs representing the swapped nibbles of a and b", "verilog": "`timescale 1ns/1ns\nmodule function_mod(\n\tinput [3:0]a,\n\tinput [3:0]b,\n\t\n\toutput [3:0]c,\n\toutput [3:0]d\n);\n\n\tassign c = data_rev(a);\n\tassign d = data_rev(b);\n\t\n\tfunction [3:0] data_rev;\n\t\t\tinput [3:0] data_in;\n\t\tbegin\n\t\t\t data_rev[0] = data_in[3];\n\t\t\t data_rev[1] = data_in[2];\n\t\t\t data_rev[2] = data_in[1];\n\t\t\t data_rev[3] = data_in[0];\n\t\tend\n\tendfunction\n\t\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg             clk;\n    reg             rst_n;\n    reg   [3:0]     a;\n    reg   [3:0]     b;\n    wire  [3:0]     c;\n    wire  [3:0]     d;\n\n    // Initialization Block\n    initial begin\n        clk = 1'b1;        // Initialize clock signal\n        rst_n = 1'b1;      // Initialize reset (active-low)\n        #50 rst_n = 1'b0;  // Assert reset after 50 ns\n        #200 $finish;      // End simulation after 200 ns\n    end\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Clock toggles every 5 ns (100 MHz)\n\n    // Random Stimulus Generation\n    always #10 a <= {$random} % 16;  // Generate random values for 'a' within 4-bit range\n    always #10 b <= {$random} % 16;  // Generate random values for 'b' within 4-bit range\n\n    // DUT (Device Under Test) Instantiation\n    top inst_function_mod (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b),\n        .c(c),\n        .d(d)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_21", "task_recommend": "This task involves creating a Verilog module that takes a 16-bit input d, a clock signal clk, a reset signal rst, and a 2-bit select signal sel. The module outputs a 4-bit signal out based on the selection and a validation signal valid_out.\n\n#### Signal Description:\nInputs:\n- d: 16-bit input signal (wire)\n- clk: Clock signal (wire)\n- rst: Reset signal (wire)\n- sel: 2-bit select signal (wire)\n\nOutputs:\n- out: 4-bit output signal (reg)\n- valid_out: Validation signal (reg)", "verilog": "`timescale 1ns/1ns\n\nmodule data_cal(\ninput clk,\ninput rst,\ninput [15:0]d,\ninput [1:0]sel,\n\noutput reg [4:0]out,\noutput reg validout\n);\n//*************code***********//\nreg [15:0] reg_d;\n\nalways @ (posedge clk or rst or d) begin\n    if(!rst) begin\n        out<=5'b0;\n\t\tvalidout<=0;\n    end\n    else begin\n        case(sel)\n\t\t\t2'b00:begin out<=5'b0; validout<=0; reg_d<=d ;end\n\t\t\t2'b01:begin out<=reg_d[3:0]+reg_d[7:4]; validout<=1; end\n\t\t\t2'b10:begin out<=reg_d[3:0]+reg_d[11:8]; validout<=1; end\n\t\t\t2'b11:begin out<=reg_d[3:0]+reg_d[15:12]; validout<=1; end\n\t\tendcase\n    end\nend\n//*************code***********//\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg             clk;\n    reg             rst;     // Active-low reset\n    reg  [15:0]     d;\n    reg  [1:0]      sel;\n    wire [4:0]      out;\n    wire            validout;\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Clock toggles every 5 ns (100 MHz)\n\n    // Initialization Block\n    initial begin\n        clk  = 1'b1;\n        rst  = 1'b0;\n        #20 rst = 1'b1;   // Release reset after 20 ns\n    end\n\n    // Testbench Stimulus\n    initial begin\n        d   = 16'd0;\n        sel = 2'd0;\n        @(posedge rst);    // Wait for reset release\n        @(posedge clk);\n        d   = 16'h8765;\n        @(posedge clk);\n        sel = 2'd1;\n        @(posedge clk);\n        @(posedge clk);\n        @(posedge clk);\n        d   = 16'h1234;\n        sel = 2'd2;\n        @(posedge clk);\n        @(posedge clk);\n        @(posedge clk);\n        sel = 2'd0;\n        @(posedge clk);\n        sel = 2'd3;\n        @(posedge clk);\n        @(posedge clk);\n        d   = 16'h2486;\n        @(posedge clk);\n        @(posedge clk);\n        @(posedge clk);\n        sel = 2'd0;\n        @(posedge clk);\n        sel = 2'd1;\n        @(posedge clk);\n        sel = 2'd0;\n        @(posedge clk);\n        sel = 2'd2;\n        @(posedge clk);\n        sel = 2'd0;\n        @(posedge clk);\n        sel = 2'd3;\n        #20\n        $finish;  // End simulation after 20 ns\n    end\n\n    // DUT (Device Under Test) Instantiation\n    top inst_data_cal (\n        .clk(clk),\n        .rst(rst),\n        .d(d),\n        .sel(sel),\n        .out(out),\n        .validout(validout)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_22", "task_recommend": "Design a Verilog module named fifo that implements a First-In-First-Out (FIFO) memory buffer using a dual-port RAM. The FIFO buffer should have configurable data width and address width parameters. The module should include control signals for reading and writing, as well as status signals indicating whether the FIFO is full or empty.\n#### Module Description:\nModules:\ndual_port_ram: A dual-port RAM module with separate read and write ports that allows simultaneous read and write operations.\nfifo: A FIFO buffer module that utilizes the dual_port_ram module to store data.\n##### dual_port_ram Module:\n####### Inputs:\nclk: Clock signal for synchronization.\nDin: 8-bit data input for writing to the RAM.\nwr_addr: 4-bit address input for write operations.\nrd_addr: 4-bit address input for read operations.\nwr_en: Write enable signal; when high, data is written to the RAM.\nrd_En: Read enable signal; when high, data is read from the RAM.\n####### Output:\nDout: 8-bit data output from the RAM.\n#####  fifo Module:\n###### Parameters:\ndata_width: Width of the data bus (default is 8 bits).\naddress_width: Width of the address bus (default is 4 bits).\nram_depth: Depth of the RAM (default is 16 locations).\n###### Inputs:\ndata_in: data_width-bit input data to be written to the FIFO.\nclk: Clock signal for synchronization.\nrst: Asynchronous reset signal.\nwe: Write enable signal; when high, data is written to the FIFO.\nre: Read enable signal; when high, data is read from the FIFO.\n###### Outputs:\ndata_out: data_width-bit output data read from the FIFO.\nfull: Signal indicating the FIFO is full.\nempty: Signal indicating the FIFO is empty.", "verilog": "module dual_port_ram(clk,Din,Dout,wr_en,wr_addr,rd_En,rd_addr);\ninput [7:0]Din;\ninput [3:0]wr_addr;\ninput [3:0]rd_addr;\ninput wr_en,rd_En,clk;\noutput reg [7:0]Dout;\nreg [7:0] Mem [15:0];\nalways @(posedge clk)\nbegin\n    if(wr_en)\n        Mem[wr_addr]<=Din;\n    if(rd_En)\n        Dout <=Mem[rd_addr];\nend\nendmodule\nmodule fifo(data_in,we,clk,rst,data_out,re,full,empty);\n    parameter data_width =8 ;\n    parameter address_width=4;\n    parameter ram_depth=16;\n    output reg [data_width-1:0]data_out;\n    output full,empty;\n    input [data_width-1:0]data_in;\n    input clk,rst,we,re;\n    reg [address_width-1:0] wr_pointer;\n    reg [address_width-1:0] rd_pointer;\n    reg [address_width:0] status_count;\n    wire [data_width-1:0] data_ram;\n    dual_port_ram DUT(clk,data_in,data_ram,we,wr_pointer,re,rd_pointer);\n//Read_pointer(4 bit counter) to read addresses\nalways @(posedge clk or posedge rst)\nbegin\n    if(rst==1)\n    rd_pointer <=0;\n    else\n    begin\n    if(re==1)\n        rd_pointer<=rd_pointer+1;\n    end\nend\nalways @(posedge clk or posedge rst) //Write_pointer(4 bit counter) to Write addresses\n    begin\n    if(rst==1)\n        wr_pointer <=0;\n    else\n        begin\n        if(we==1)\n            wr_pointer<=wr_pointer+1;\n        end\nend\n//Status (5bit Counter) Pointer For Full and Empty\nalways @(posedge clk,posedge rst)\nbegin\nif(rst)\n    status_count<=0;\nelse if ((we&&!re) && (status_count !=ram_depth))\n    status_count<=status_count+1;\nelse if ((re&&!we) && (status_count !=0) )\n    status_count<=status_count-1;\nend\nassign full=(status_count==(ram_depth));\nassign empty=(status_count==0);\n//Read Logic\nalways @(posedge clk,posedge rst)\nbegin\nif(rst)\n    data_out<=0;\nelse\n   begin\nif(rst)\n    data_out<=data_ram;\nend\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg [7:0] data_in_tb;\n    reg clk_tb, rst_tb, we_tb, re_tb;\n    wire [7:0] data_out_tb;\n    wire full_tb, empty_tb;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .data_in(data_in_tb),\n        .we(we_tb),\n        .clk(clk_tb),\n        .rst(rst_tb),\n        .data_out(data_out_tb),\n        .re(re_tb),\n        .full(full_tb),\n        .empty(empty_tb)\n    );\n\n    // Clock Generation\n    always begin\n        clk_tb = 1;\n        #5;\n        clk_tb = 0;\n        #5;\n    end\n\n    // Task to Initialize Signals\n    task initialize;\n    begin\n        we_tb = 0;\n        re_tb = 0;\n        data_in_tb = 0;\n    end\n    endtask\n\n    // Task to Reset the Design\n    task rst;\n    begin\n        @(negedge clk_tb)\n        rst_tb = 1;\n        @(negedge clk_tb)\n        rst_tb = 0;\n    end\n    endtask\n\n    // Task to Write Operation\n    task write_operation(input a);\n    begin\n        @(negedge clk_tb)\n        we_tb = a;\n    end\n    endtask\n\n    // Task to Read Operation\n    task read_operation(input b);\n    begin\n        @(negedge clk_tb)\n        re_tb = b;\n    end\n    endtask\n\n    // Task to Provide Data Input\n    task data_input(input [7:0] c);\n    begin\n        @(negedge clk_tb)\n        data_in_tb = c;\n    end\n    endtask\n\n    // Initial Block to Apply Stimulus\n    initial begin\n        initialize;\n        rst;\n        write_operation(1);\n        repeat(16) begin\n            data_input($random % 256);\n        end\n        write_operation(0);\n        read_operation(1);\n        #200; read_operation(0);\n        rst;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_23", "task_recommend": "Use FSM to implement a vending machine. Vending machine description: The product is cola, a bottle of cola costs 5 yuan, and you can only put in one of the three types of RMB each time, namely: 1 yuan, 2 yuan, and 5 yuan. When 5 yuan is put in, a bottle of cola will be taken out and change will be given. The input includes: clock signal clk, low-level reset signal rst_n, coin in_m. The output includes: cola goods, change out_m. According to how much money is in the vending machine, the state machine is divided into 5 states, namely: IDLE (0 yuan), S0 (1 yuan), S1 (2 yuan), S2 (3 yuan), S3 (4 yuan). A mealy state machine is used. Each state is encoded with a one-hot code, and 5 states require 5 bits.", "verilog": "`timescale 1ns/1ns\n \nmodule FSM (\n\tinput clk,\n\tinput rst_n,\n\tinput [3:0] in_m,\n\toutput reg goods,\n\toutput reg [3:0] out_m\n);\n \nreg [4:0] CS, NS;\n \nparameter [4:0]\n\tIDLE = 'b00001,\n\tS0   = 'b00010,\n\tS1   = 'b00100,\n\tS2   = 'b01000,\n\tS3   = 'b10000;\n//第一always块，同步时序逻辑\nalways @ (posedge clk or negedge rst_n) begin\n\tif (!rst_n)\n\t\tCS <= IDLE;\n\telse\n\t\tCS <= NS;\nend\n//第二always块，组合逻辑\nalways @ (*) begin\n\tcase (CS)\n\t\tIDLE:\n\t\t\tif (in_m == 4'd1)\t\tNS = S0;\n\t\t\telse if (in_m == 4'd2)\tNS = S1;\n\t\t\telse if (in_m == 4'd5)\tNS = IDLE;\n\t\t\telse\t\t\t\t\tNS = IDLE;\n\t\t\n\t\tS0:\n\t\t\tif (in_m == 4'd1)\t\tNS = S1;\n\t\t\telse if (in_m == 4'd2)\tNS = S2;\n\t\t\telse if (in_m == 4'd5)\tNS = IDLE;\n\t\t\telse\t\t\t\t\tNS = S0;\n\t\t\n\t\tS1:\n\t\t\tif (in_m == 4'd1)\t\tNS = S2;\n\t\t\telse if (in_m == 4'd2)\tNS = S3;\n\t\t\telse if (in_m == 4'd5)\tNS = IDLE;\n\t\t\telse\t\t\t\t\tNS = S1;\n\t\t\n\t\tS2:\n\t\t\tif (in_m == 4'd1)\t\tNS = S3;\n\t\t\telse if (in_m == 4'd2)\tNS = IDLE;\n\t\t\telse if (in_m == 4'd5)\tNS = IDLE;\n\t\t\telse\t\t\t\t\tNS = S2;\n\t\t\n\t\tS3:\n\t\t\tif (in_m == 4'd1)\t\tNS = IDLE;\n\t\t\telse if (in_m == 4'd2)\tNS = IDLE;\n\t\t\telse if (in_m == 4'd5)\tNS = IDLE;\n\t\t\telse\t\t\t\t\tNS = S3;\n\t\n\t\tdefault:\n\t\t\tNS = IDLE;\n\tendcase\nend\n \n//第三always块，同步时序逻辑\nalways @ (posedge clk or negedge rst_n) begin\n\tif (!rst_n) begin\n\t\tout_m <= 'd0;\n\t\tgoods <= 'd0;\n\tend\n\telse begin\n\t\tcase (CS)\n\t\t\tIDLE: begin\n\t\t\t\tout_m <= 'd0;\n\t\t\t\tif (in_m == 'd5)    goods <= 'd1;\n\t\t\t\telse                goods<= 'd0;\n\t\t\tend\n\t\t\t\n\t\t\tS0: begin\n\t\t\t\tout_m <= 'd0;\n\t\t\t\tif (in_m == 'd1 || in_m == 'd2) begin\n\t\t\t\t\tgoods <= 'd0;\n\t\t\t\t\tout_m <= 'd0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tgoods <= 'd1;\n\t\t\t\t\tout_m <= 'd1;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tS1: begin\n\t\t\t\tout_m <= 'd0;\n\t\t\t\tif (in_m == 'd1 || in_m == 'd2) begin\n\t\t\t\t\tgoods <= 'd0;\n\t\t\t\t\tout_m <= 'd0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tgoods <= 'd1;\n\t\t\t\t\tout_m <= 'd2;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\t\n\t\t\tS2: begin\n\t\t\t\tout_m <= 'd0;\n\t\t\t\tif (in_m == 'd1) begin\n\t\t\t\t\tgoods <= 'd0;\n\t\t\t\t\tout_m <= 'd0;\n\t\t\t\tend\n\t\t\t\telse if (in_m == 'd2) begin\n\t\t\t\t\tgoods <= 'd1;\n\t\t\t\t\tout_m <= 'd0;\n\t\t\t\tend\n\t\t\t\telse begin\n\t\t\t\t\tgoods <= 'd1;\n\t\t\t\t\tout_m <= 'd3;\n\t\t\t\tend\n\t\t\tend\n\t\t\t\n\t\t\tS3: begin\n\t\t\t\tgoods <= 'd1;\n\t\t\t\tif (in_m == 'd1)\t\tout_m <= 'd0;\n\t\t\t\telse if (in_m == 'd2)\tout_m <= 'd1;\n\t\t\t\telse\t\t\t\t\tout_m <= 'd4;\n\t\t\tend\n\t\t\t\n\t\t\tdefault: begin\n\t\t\t\tgoods <= 'd1;\n\t\t\t\tout_m <= 'd0;\n\t\t\tend\n\t\tendcase\n\tend\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg clk;\n    reg rst_n;\n    reg [3:0] in_m;\n    wire [3:0] out_m;\n    wire goods;\n\n    // Instantiate the DUT (Device Under Test)\n    top u (\n        .clk(clk),\n        .rst_n(rst_n),\n        .in_m(in_m),\n        .goods(goods),\n        .out_m(out_m)\n    );\n\n    // Clock Generation\n    always #20 clk = ~clk;  // Clock toggles every 20 ns\n\n    // Initialization Block\n    initial begin\n        rst_n = 1'b0;\n        clk = 1'b0;\n        #50 rst_n = 1'b1;  // Release reset after 50 ns\n    end\n\n    // Testbench Stimulus\n    initial begin\n        in_m = 4'b0000;\n        #50 in_m = 4'd1;\n        #40 in_m = 4'd1;\n        #40 in_m = 4'd1;\n        #40 in_m = 4'd1;\n        #40 in_m = 4'd1;\n        #40 in_m = 4'd2;\n        #40 in_m = 4'd2;\n        #40 in_m = 4'd2;\n        #40 in_m = 4'd5;\n        #40 in_m = 4'd2;\n        #40 in_m = 4'd5;\n        #40 $stop;  // Stop simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_24", "task_recommend": "This example is a register-transfer level version of the gate-level shift register.\n\n#### Design Requirements:\n\n- **Implement a shift register:** A data value is shifted in on every clock cycle, on the rising edge, and the oldest value is shifted out. The shift register is FIFO. The shifted-out value is available after the falling edge of the clock.\n- **Depth of the shift register:** 4 bits.\n- **Module ports:** \n  - Data input (1 bit)\n  - Clock (1 bit)\n  - Data output (1 bit)", "verilog": "module Reg8x (regOut, regIn, notReset, clock, \n              scanShiftOut, scanShiftIn, scanShiftEnable);\n    /* Parameters: */\n    parameter       size = 8;\n    parameter       ckToQ = 1;\n    parameter       resetToQ = 1;\n    \n    /* I/O Descriptions: */\n    output [size-1:0]   regOut;         /* register output */\n    input [size-1:0]    regIn;          /* register input */\n    input               notReset;       /* async reset */\n    input               clock;\n    output              scanShiftOut;       /* output of scan chain */\n    input               scanShiftIn;        /* serial scan input */\n    input               scanShiftEnable;    /* '1' = shift */\n    \n    reg [size-1:0] regOut;          /* temp variable */\n    reg            shiftOut;        /* temp variable */\n    \n    /* Assignments: */\n    assign scanShiftOut = regOut[size-1];\n    \n    /* Register Functionality */\n    always @(posedge clock)\n        if (notReset && (scanShiftEnable !== 1))\n             regOut = #ckToQ regIn;\n    \n    /* Scan Operation */\n    always @(posedge scanShiftEnable)\n        while (scanShiftEnable === 1)\n            @(posedge clock)\n            if (scanShiftEnable && notReset)\n                {shiftOut, regOut} = #ckToQ {regOut, scanShiftIn};\n    \n    /* Reset Operation */\n    initial begin\n        if (!notReset) \n            regOut = #resetToQ {size{1'b0}};  // avoid start-up race\n        forever @(negedge notReset)\n            regOut = #resetToQ {size{1'b0}};\n    end\nendmodule   /* Reg8x */\n", "test": "`timescale 1ns/1ns\n\nmodule clkGen (clk);\n    parameter period = 2;\n    output reg clk;\n\n    // Initialize clock\n    initial clk = 0;           // Start off with 0\n\n    // Clock generation loop\n    always #(period/2) clk = ~clk;\nendmodule\n\nmodule tb;\n    // Signal Declarations\n    wire clk;             // Clock signal\n    wire [7:0] Q;         // Output of register\n    wire scanOut;         // Scan data out\n    reg [7:0] dataIn;     // Input data\n    reg notReset, scanIn, scanEn;\n\n    // Module Instances\n    top r1 (Q, dataIn, notReset, clk, scanOut, scanIn, scanEn);\n    clkGen #(10) cg (clk);  // Generate the clock with a period of 10 ns\n\n    integer i;\n    reg [11:0] scantest;\n\n    // Testbench Stimulus\n    initial begin\n        $monitor($time, \" dataIn: %b Q: %b\", dataIn, Q);\n        \n        // Initialize signals\n        notReset = 0;           // Reset active\n        scanEn = 0;             // Disable scan\n        dataIn = 8'b00000000;   // Initialize input data\n        \n        #15 notReset = 1;       // Release reset after 15 ns\n        dataIn = 8'b00000001;   // Load initial data\n        \n        // Shift left data into the register\n        repeat (4) begin\n            #10 dataIn = dataIn << 1;\n        end\n        \n        #5 notReset = 0;        // Assert reset\n        #10 notReset = 1;       // Release reset again on clock edge\n\n        // Shift left data into the register again\n        repeat (4) begin\n            #10 dataIn = dataIn << 1;\n        end\n\n        // Test scan functionality\n        #10 scanEn = 1;         // Enable scan\n        $monitor($time, \" dataIn: %b Q: %b scanIn: %b scanOut: %b\", dataIn, Q, scanIn, scanOut);\n        scanIn = 0;\n        scantest = 12'b100110001110;\n        \n        // Apply scan test sequence\n        for (i = 0; i < 12; i = i + 1) begin\n            #10 scanIn = scantest[i];\n        end\n        \n        #10 $finish;            // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GA_25", "task_recommend": "he following hierarchy uses an upward XMR with instance names which can not be resolved. Can you modify it so that both instances of module moda will print out the value of z contained in their sibling? That is, one should print xx.z = 2 and the other should print xx.z = 4.", "verilog": "module moda;\n    parameter zz = 0;\n    \n    initial   $display(\"from %m: xx.z = %d\", xx.z);    \nendmodule\n\n\nmodule modb;\n    parameter z = 0;\n    \n    moda #(3) xa();   // <<< change instance name\n    modc #(4) xx();   // <<< change instance name\n        \nendmodule\n\n\nmodule modc;\n    parameter z = 0;        \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Instantiate moda with parameter value 1\n    moda #(1) a1();\n    \n    // Instantiate modb with parameter value 2\n    modb #(2) xx();\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_3", "task_recommend": "Design a 4-bit carry look-ahead adder using Verilog HDL. The adder should have two 4-bit inputs (`A_in`, `B_in`) and a single-bit carry input (`C_1`). It should produce a 4-bit sum output (`S`) and a single-bit carry-out output (`CO`).\nThe logic equations are as follows:\n- Generate \\( G_i = A_i \\cdot B_i \\)\n- Propagate \\( P_i = A_i \\oplus B_i \\)\n- Sum \\( S_i = P_i \\oplus C_i \\)\n- Carry-out \\( C_{i+1} = G_i + P_i \\cdot C_i \\)\n#### Input Description:\n- **Input Signals**:\n  - `A_in[3:0]`\n  - `B_in[3:0]`\n  - `C_1`\n  - **Type**: `wire`\n#### Output Description:\n- **Output Signals**:\n  - `S[3:0]`\n  - `CO`\n  - **Type**: `wire`", "verilog": "`timescale 1ns/1ns\n\nmodule lca_4(\n\tinput\t\t[3:0]       A_in  ,\n\tinput\t    [3:0]\t\tB_in  ,\n    input                   C_1   ,\n \n \toutput\t wire\t\t\tCO    ,\n\toutput   wire [3:0]\t    S\n);\nwire[3:0] g,p,c;\nassign p=A_in|B_in;\nassign g=A_in&B_in;\nassign c[0]=g[0]|(p[0]&C_1);\nassign c[1]=g[1]|(p[1]&(g[0]|(p[0]&C_1)));\nassign c[2]=g[2]|(p[2]&(g[1]|(p[1]&(g[0]|(p[0]&C_1)))));\nassign c[3]=g[3]|(p[3]&(g[2]|(p[2]&(g[1]|(p[1]&(g[0]|(p[0]&C_1))))))); \nassign CO=c[3];\n\nassign S=A_in^B_in^{c[2:0],C_1};\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Input signals\n    reg [3:0] A_in, B_in;\n    reg C_1;\n\n    // Output signals\n    wire CO;\n    wire [3:0] S;\n\n    // Internal testbench variable\n    reg [7:0] num;\n\n    // Instantiate the DUT (Device Under Test)\n    top U1 (\n        .A_in(A_in),\n        .B_in(B_in),\n        .C_1(C_1),\n        .CO(CO),\n        .S(S)\n    );\n\n    // Initialize inputs\n    initial begin\n        C_1 = 0;\n        num = 0;\n    end\n\n    // Generate stimulus\n    always #10 begin\n        num = num + 1;\n        A_in <= num[3:0];\n        B_in <= num[7:4];\n    end\nendmodule\n"}
{"task_id": "GA_4", "task_recommend": "This task involves creating a Verilog module that takes an 8-bit input d, a clock signal clk, and a reset signal rst. The module stores every input value and outputs a combination of three specific stored values (values at times 1, 3, 7, and 8) as a 11-bit out. The input_grant signal indicates when a new input has been granted.\n\nInputs:\n- d: 8-bit input signal (wire)\n- clk: Clock signal (wire)\n- rst: Reset signal (wire)\n\nOutputs:\n- input_grant: Signal indicating a new input grant (reg)\n- out: 11-bit output signal (reg)", "verilog": "`timescale 1ns/1ns\n \nmodule multi_sel(\n\tinput      [7:0]    d ,\n\tinput               clk,\n\tinput               rst,   //复位，低有效\n\toutput reg          input_grant,\n\toutput reg [10:0]   out\n);\n//*************code***********//\nreg  [7:0]     d_reg;\nreg  [1:0]     cnt;\n \n//循环计数器\nalways @(posedge clk or negedge rst) begin\n\tif (!rst) begin\n\t\tcnt <= 'd0;\n\tend\n\telse begin\n\t\tcnt <= cnt + 'd1;\n\tend\nend\n \n//每当合适时间数据来临时将数据寄存\nalways @(posedge clk or negedge rst) begin\n\tif (!rst) begin\n\t\td_reg <= 'd0;\n\tend\n\telse if (cnt == 'd0) begin\n\t\td_reg <= d;\n\tend\n\telse begin\n\t\td_reg <= d_reg;\n\tend\nend\n \n//根据计数值输出相应的数值\nalways @(posedge clk or negedge rst) begin\n\tif (!rst) begin\n\t\tout <= 'd0;\n\tend\n\telse if (cnt == 'd0) begin      \n\t\tout <= d;                      //乘1\n\tend\n\telse if (cnt == 'd1) begin\n\t\tout <= (d_reg << 2) - d_reg;   //乘3\n\tend\n\telse if (cnt == 'd2) begin\n\t\tout <= (d_reg << 3) - d_reg;   //乘7\n\tend\n\telse if (cnt == 'd3) begin\n\t\tout <= (d_reg << 3);           //乘8\n\tend\n\telse begin\n\t\tout <= out;\n\tend\nend\n//输出有效数据标志信号\nalways @(posedge clk or negedge rst) begin\n\tif (!rst) begin\n\t\tinput_grant <= 'd0;\n\tend\n\telse if (cnt == 'd0) begin\n\t\tinput_grant <= 'd1;\n\tend\n\telse begin\n\t\tinput_grant <= 'd0;\n\tend\nend\n//*************code***********//\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg            clk;\n    reg            rst;     // Active-low reset\n    reg  [7:0]     d;\n    wire [10:0]    out;\n    wire           input_grant;\n\n    // Clock Generation\n    always #5 clk = ~clk;\n\n    // Initialization and Test Sequence\n    initial begin\n        clk  = 1;\n        rst  = 0;\n        #50 rst = 1; // Release reset after 50 ns\n    end\n\n    initial begin\n        d = 8'd23;  // Initial data value\n        @(posedge rst);  // Wait for reset de-assertion\n        repeat (4) @(posedge clk);\n        d = 8'd7;\n        @(posedge clk);\n        d = 8'd6;\n        @(posedge clk);\n        d = 8'd12;\n        repeat (8) @(posedge clk);\n        d = 8'd4;\n        repeat (2) @(posedge clk);\n        d = 8'd9;\n        repeat (5) @(posedge clk);\n        d = 8'd12;\n        #100 $finish;  // End simulation after 100 ns\n    end\n\n    // DUT (Device Under Test) Instantiation\n    top inst_multi_sel (\n        .d(d),\n        .clk(clk),\n        .rst(rst),\n        .input_grant(input_grant),\n        .out(out)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_5", "task_recommend": "Design a submodule that compares two 8-bit input variables data_a and data_b and outputs the smaller of the two values. Then instantiate this submodule in a main module to find the minimum value among three 8-bit inputs a, b, and c.\n\nInputs:\n- clk: System clock\n- rst_n: Active-low reset signal\n- data_a: 8-bit unsigned input\n- data_b: 8-bit unsigned input\n\nOutput:\n- c: 8-bit unsigned output representing the smaller of data_a and data_b", "verilog": "module main_mod(\n\tinput           clk,\n\tinput           rst_n,\n\tinput  [7:0]    a,\n\tinput  [7:0]    b,\n\tinput  [7:0]    c,\n\toutput [7:0]    d\n);\n \n    reg   [7:0]     c_reg;\n    wire  [7:0]     min;\n\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            c_reg <= 'd0;\n        end\n        else begin\n            c_reg <= c;\n        end\n    end\n    compare_min compare_min_inst1 (\n        .clk     (clk),\n        .rst_n   (rst_n),\n        .a       (a),\n        .b       (b),\n        .c       (min)\n    );\n    compare_min compare_min_inst2 (\n        .clk     (clk),\n        .rst_n   (rst_n),\n        .a       (min),\n        .b       (c_reg),\n        .c       (d)\n    );\nendmodule\nmodule compare_min(\n\tinput               clk,\n\tinput               rst_n,\n\tinput      [7:0]    a,\n\tinput      [7:0]    b,\n\toutput reg [7:0]    c\n\t);\n    always @(posedge clk or negedge rst_n) begin\n        if (!rst_n) begin\n            c <= 8'd0;\n        end\n        else if (a < b) begin\n            c <= a;\n        end\n        else begin\n            c <= b;\n        end\n    end\n \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg            clk;\n    reg            rst_n;\n    reg  [7:0]     a;\n    reg  [7:0]     b;\n    reg  [7:0]     c;\n    wire [7:0]     d;\n\n    // Initialization Block\n    initial begin\n        clk   = 1'b1;\n        rst_n = 1'b0;\n        a     = 8'd0;\n        b     = 8'd0;\n        c     = 8'd0;\n        #20 rst_n = 1'b1;  // Release reset after 20 ns\n        #200 $finish;      // End simulation after 200 ns\n    end\n\n    // Clock Generation\n    always #5 clk = ~clk;\n\n    // Random Stimulus Generation\n    always #10 a <= {$random} % 8'd256;  // Random value for 'a' within 8-bit range\n    always #10 b <= {$random} % 8'd256;  // Random value for 'b' within 8-bit range\n    always #10 c <= {$random} % 8'd256;  // Random value for 'c' within 8-bit range\n\n    // DUT (Device Under Test) Instantiation\n    top inst_main_mod (\n        .clk   (clk),\n        .rst_n (rst_n),\n        .a     (a),\n        .b     (b),\n        .c     (c),\n        .d     (d)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_6", "task_recommend": "Design a 4-bit carry look-ahead adder using Verilog HDL. The adder should have two 4-bit inputs (`A_in`, `B_in`) and a single-bit carry input (`C_1`). It should produce a 4-bit sum output (`S`) and a single-bit carry-out output (`CO`).\n\nThe logic equations are as follows:\n- Generate \\( G_i = A_i \\cdot B_i \\)\n- Propagate \\( P_i = A_i \\oplus B_i \\)\n- Sum \\( S_i = P_i \\oplus C_i \\)\n- Carry-out \\( C_{i+1} = G_i + P_i \\cdot C_i \\)\n#### Input Description:\n- **Input Signals**:\n  - `A_in[3:0]`\n  - `B_in[3:0]`\n  - `C_1`\n  - **Type**: `wire`\n\n#### Output Description:\n- **Output Signals**:\n  - `S[3:0]`\n  - `CO`\n  - **Type**: `wire`", "verilog": "`timescale 1ns/1ns\n \nmodule lca_4(\n\tinput\t\t [3:0]      A_in  ,\n\tinput\t     [3:0]\t\tB_in  ,\n    input                   C_1   ,\n \n \toutput\twire\t\t\tCO    ,\n\toutput  wire [3:0]\t    S\n);\n \n    wire  [3:0]    G;\n    wire  [3:0]    P;\n    wire  [3:0]    C;\n\n    //第0位\n    assign G[0] = A_in[0] & B_in[0];\n    assign P[0] = A_in[0] ^ B_in[0];\n    assign C[0] = G[0] | (P[0] & C_1);\n    assign S[0] = P[0] ^ C_1;\n\n    //第1位\n    assign G[1] = A_in[1] & B_in[1];\n    assign P[1] = A_in[1] ^ B_in[1];\n    assign C[1] = G[1] | (P[1] & C[0]);\n    assign S[1] = P[1] ^ C[0];\n\n    //第2位\n    assign G[2] = A_in[2] & B_in[2];\n    assign P[2] = A_in[2] ^ B_in[2];\n    assign C[2] = G[2] | (P[2] & C[1]);\n    assign S[2] = P[2] ^ C[1];\n\n    //第3位\n    assign G[3] = A_in[3] & B_in[3];\n    assign P[3] = A_in[3] ^ B_in[3];\n    assign C[3] = G[3] | (P[3] & C[2]);\n    assign S[3] = P[3] ^ C[2];\n\n    assign CO = C[3];\n    \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  [3:0]  A_in;\n    reg  [3:0]  B_in;\n    reg         C_1;\n    wire        CO;\n    wire        S;\n\n    // Initialization Block\n    initial begin\n        A_in = 4'd12;\n        B_in = 4'd10;\n        C_1  = 1'b1;\n        #200\n        $finish;\n    end\n\n    // Random Stimulus Generation\n    always #10 A_in <= {$random} % 4'd16;  // Random value for A_in within 4-bit range\n    always #10 B_in <= {$random} % 4'd16;  // Random value for B_in within 4-bit range\n    always #10 C_1  <= {$random} % 2'd2;   // Random value for C_1 (1-bit range)\n\n    // DUT (Device Under Test) Instantiation\n    top inst_lca_4 (\n        .A_in(A_in),\n        .B_in(B_in),\n        .C_1(C_1),\n        .CO(CO),\n        .S(S)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_7", "task_recommend": "Please use 2 pieces of this priority encoder I and the necessary logic circuit to implement a 16-line to 4-line priority encoder.The code of priority encoder I has been given. The code of priority encoder I can be added to the answer to this question and instantiated.\nthis priority encoder I code:\n```\nmodule encoder_83(\n   input      [7:0]       I   ,\n   input                  EI  ,\n   \n   output wire [2:0]      Y   ,\n   output wire            GS  ,\n   output wire            EO    \n);\nassign Y[2] = EI & (I[7] | I[6] | I[5] | I[4]);\nassign Y[1] = EI & (I[7] | I[6] | ~I[5]&~I[4]&I[3] | ~I[5]&~I[4]&I[2]);\nassign Y[0] = EI & (I[7] | ~I[6]&I[5] | ~I[6]&~I[4]&I[3] | ~I[6]&~I[4]&~I[2]&I[1]);\n \nassign EO = EI&~I[7]&~I[6]&~I[5]&~I[4]&~I[3]&~I[2]&~I[1]&~I[0];\n \nassign GS = EI&(I[7] | I[6] | I[5] | I[4] | I[3] | I[2] | I[1] | I[0]);\n//assign GS = EI&(| I);\n```", "verilog": "module encoder_164(\n   input      [15:0]      A   ,\n   input                  EI  ,\n   \n   output wire [3:0]      L   ,\n   output wire            GS  ,\n   output wire            EO    \n);\n \nwire  [2:0]    Y0;\nwire  [2:0]    Y1;\nwire           GS0;\nwire           GS1;\nwire           E0_0;\nwire           E0_1;\n \nencoder_83 inst_encoder_83_0 (\n\t.I(A[7:0]), \n\t.EI(EI), \n\t.Y(Y0), \n\t.GS(GS0), \n\t.EO(EO_0)\n);\n \nencoder_83 inst_encoder_83_1 (\n\t.I(A[15:8]), \n\t.EI(EI), \n\t.Y(Y1), \n\t.GS(GS1), \n\t.EO(EO_1)\n);\n \nassign L[3] = GS1;\nassign L[2] = (L[3]==0) ? Y0[2] : Y1[2];\nassign L[1] = (L[3]==0) ? Y0[1] : Y1[1];\nassign L[0] = (L[3]==0) ? Y0[0] : Y1[0];\n \nassign GS = GS0 | GS1;\n \nassign EO = EO_0 & EO_1;\n \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg   [15:0] A;\n    reg          EI;\n    wire  [3:0]  L;\n    wire         GS;\n    wire         EO;\n\n    // Initialization Block\n    initial begin\n        A  = 16'd0;\n        EI = 1'b0;\n        #200\n        $finish;  // End simulation after 200 ns\n    end\n\n    // Random Stimulus Generation\n    always #10 A  <= {$random} % 16'd65536;  // Random value for A within 16-bit range\n    always #10 EI <= {$random} % 2'd2;       // Random value for EI (1-bit range)\n\n    // DUT (Device Under Test) Instantiation\n    top encoder_164_inst (\n        .A  (A),\n        .EI (EI),\n        .L  (L),\n        .GS (GS),\n        .EO (EO)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_8", "task_recommend": "Please use the 3-8 decoder and necessary logic gates to implement the function L=(~A)·C+A·B. The 3-8 decoder code is as follows.\n3-8 decoder\n```\nmodule decoder_38(\n   input             E1_n   ,\n   input             E2_n   ,\n   input             E3     ,\n   input             A0     ,\n   input             A1     ,\n   input             A2     ,\n   \n   output wire       Y0_n   ,  \n   output wire       Y1_n   , \n   output wire       Y2_n   , \n   output wire       Y3_n   , \n   output wire       Y4_n   , \n   output wire       Y5_n   , \n   output wire       Y6_n   , \n   output wire       Y7_n   \n);\nwire E ;\nassign E = E3 & ~E2_n & ~E1_n;\nassign  Y0_n = ~(E & ~A2 & ~A1 & ~A0);\nassign  Y1_n = ~(E & ~A2 & ~A1 &  A0);\nassign  Y2_n = ~(E & ~A2 &  A1 & ~A0);\nassign  Y3_n = ~(E & ~A2 &  A1 &  A0);\nassign  Y4_n = ~(E &  A2 & ~A1 & ~A0);\nassign  Y5_n = ~(E &  A2 & ~A1 &  A0);\nassign  Y6_n = ~(E &  A2 &  A1 & ~A0);\nassign  Y7_n = ~(E &  A2 &  A1 &  A0);\n     \nendmodule\n```", "verilog": "module decoder0(\n   input             A     ,\n   input             B     ,\n   input             C     ,\n   \n   output wire       L\n);\n \nwire    Y0_n,Y1_n,Y2_n,Y3_n,Y4_n,Y5_n,Y6_n,Y7_n;\n \ndecoder_38 inst_decoder_38(\n\t\t.E1_n (0),\n\t\t.E2_n (0),\n\t\t.E3   (1),\n\t\t.A0   (A),\n\t\t.A1   (B),\n\t\t.A2   (C),\n\t\t.Y0_n (Y0_n),\n\t\t.Y1_n (Y1_n),\n\t\t.Y2_n (Y2_n),\n\t\t.Y3_n (Y3_n),\n\t\t.Y4_n (Y4_n),\n\t\t.Y5_n (Y5_n),\n\t\t.Y6_n (Y6_n),\n\t\t.Y7_n (Y7_n)\n\t);\n \nassign L = ~Y3_n | ~Y4_n | ~Y6_n | ~Y7_n;\n \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  A;\n    reg  B;\n    reg  C;\n    wire L;\n\n    // Initialization Block\n    initial begin\n        A = 1'b1;\n        B = 1'b1;\n        C = 1'b1;\n        #200\n        $finish;  // End simulation after 200 ns\n    end\n\n    // Random Stimulus Generation\n    always #10 A <= {$random} % 2;  // Random value for A (1-bit range)\n    always #10 B <= {$random} % 2;  // Random value for B (1-bit range)\n    always #10 C <= {$random} % 2;  // Random value for C (1-bit range)\n\n    // DUT (Device Under Test) Instantiation\n    top decoder0_inst (\n        .A (A),\n        .B (B),\n        .C (C),\n        .L (L)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GA_9", "task_recommend": "Please use the 3-8 decoder and necessary logic gates to implement the full subtractor. The interface diagram of the full subtractor is as follows. A is the minuend, B is the subtrahend, Ci is the borrow bit from the low bit, D is the difference, and Co is Borrowing from a higher position.The 3-8 decoder code is as follows.\n3-8 decoder\n```\nmodule decoder_38(\n   input             E      ,\n   input             A0     ,\n   input             A1     ,\n   input             A2     ,\n   \n   output reg       Y0n    ,  \n   output reg       Y1n    , \n   output reg       Y2n    , \n   output reg       Y3n    , \n   output reg       Y4n    , \n   output reg       Y5n    , \n   output reg       Y6n    , \n   output reg       Y7n    \n);\n \nalways @(*)begin\n   if(!E)begin\n      Y0n = 1'b1;\n      Y1n = 1'b1;\n      Y2n = 1'b1;\n      Y3n = 1'b1;\n      Y4n = 1'b1;\n      Y5n = 1'b1;\n      Y6n = 1'b1;\n      Y7n = 1'b1;\n   end  \n   else begin\n      case({A2,A1,A0})\n         3'b000 : begin\n                     Y0n = 1'b0; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b1;\n                  end \n         3'b001 : begin\n                     Y0n = 1'b1; Y1n = 1'b0; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b1;\n                  end \n         3'b010 : begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b0; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b1;\n                  end \n         3'b011 : begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b0; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b1;\n                  end \n         3'b100 : begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b0; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b1;\n                  end \n         3'b101 : begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b0; Y6n = 1'b1; Y7n = 1'b1;\n                  end \n         3'b110 : begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b0; Y7n = 1'b1;\n                  end \n         3'b111 : begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b0;\n                  end \n         default: begin\n                     Y0n = 1'b1; Y1n = 1'b1; Y2n = 1'b1; Y3n = 1'b1; \n                     Y4n = 1'b1; Y5n = 1'b1; Y6n = 1'b1; Y7n = 1'b1;\n                  end\n      endcase  \n   end \nend    \n     \nendmodule\n\n```", "verilog": "module decoder1(\n   input             A     ,\n   input             B     ,\n   input             Ci    ,\n   \n   output wire       D     ,\n   output wire       Co         \n);\n \nwire   Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7;\n \ndecoder_38 inst(1'b1,Ci,B,A,Y0,Y1,Y2,Y3,Y4,Y5,Y6,Y7);\n \nassign D  = ~(Y1 & Y2 & Y4 & Y7);\nassign Co = ~(Y1 & Y2 & Y3 & Y7);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  A;\n    reg  B;\n    reg  Ci;\n    wire D;\n    wire Co;\n\n    // Initialization Block\n    initial begin\n        A  = 1'b0;\n        B  = 1'b0;\n        Ci = 1'b0;\n        #200\n        $finish;  // End simulation after 200 ns\n    end\n\n    // Random Stimulus Generation\n    always #10 A  <= {$random} % 2;  // Random value for A (1-bit range)\n    always #10 B  <= {$random} % 2;  // Random value for B (1-bit range)\n    always #10 Ci <= {$random} % 2;  // Random value for Ci (1-bit range)\n\n    // DUT (Device Under Test) Instantiation\n    top decoder_38_inst (\n        .A  (A),\n        .B  (B),\n        .Ci (Ci),\n        .D  (D),\n        .Co (Co)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_1", "task_recommend": "Create a module that implements a NOT gate, two inputs and one output.", "verilog": "module gates ( input a,\n               output b);\n   not (b, a);  // b is the output, a is input\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a;\n    wire b;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a),\n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        a = 0; // Initialize input\n        $monitor(\"T=%t a=%b  b(not)=%b\", $time, a, b); // Monitor signal changes\n\n        // Generate random values for 'a'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_10", "task_recommend": "Create a module that implements a OR gate, Four inputs and one output.", "verilog": "module gates ( input a, b, c, d,\n               output e);\n    // in this example\n    or (e, a, b, c, d);  // c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, c, d;\n    wire e;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c), \n        .d(d), \n        .e(e)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b, c, d} = 4'b0000; // Initialize all inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c=%b d=%b e(or)=%b\", $time, a, b, c, d, e); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n               c = $random; // Assign random values to 'c'\n               d = $random; // Assign random values to 'd'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_11", "task_recommend": "Design a Verilog module named Half_Subtractor that implements a simple digital logic circuit called a Half Subtractor. A Half Subtractor is a binary subtraction module used for two input bits to produce a Difference and a Borrow output.", "verilog": "module Half_Subtractor(a,b,difference,barrow);\ninput a,b;\noutput reg difference,barrow;\nalways@(a,b)\nbegin\n\tdifference<=a^b;\n\tbarrow<=a&(~b);\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a_tb, b_tb;\n    wire barrow_tb, difference_tb;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .a(a_tb), \n        .b(b_tb), \n        .difference(difference_tb), \n        .barrow(barrow_tb)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        for (i = 0; i < 4; i = i + 1) begin\n            {a_tb, b_tb} = i; // Assign values to a_tb and b_tb\n            #10; // Wait for 10 time units\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_12", "task_recommend": "A module `des` that has two gates with explicit delay specifications: an AND gate (`and`) with a delay of 2 time units and a hypothetical BUFIFO gate (`bufifo`) with a delay of 3 time units. These delays simulate the propagation delay through each gate.", "verilog": "module des ( input a, b, \n             output out1, out2);\n\n    // AND gate has 2 time unit gate delay\n    and    #(2) o1 (out1, a, b);\n\n    // BUFFIFO gate has 3 time unit gate delay\n    bufifo #(3) b1 (out2, a, b);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out1, out2;\n\n    // Instantiate the DUT (Device Under Test)\n    top d0 (\n        .out1(out1), \n        .out2(out2), \n        .a(a), \n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t a=%b b=%b and=%b bufifo=%b\", $time, a, b, out1, out2); // Monitor signal changes\n\n        #10 a = 1; // Set a to 1 after 10 time units\n        #10 b = 1; // Set b to 1 after 20 time units\n        #10 a = 0; // Set a to 0 after 30 time units\n        #10 b = 0; // Set b to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_13", "task_recommend": "a module named `des` with two gates, each with two different delay specifications for the rise and fall times:\n- `and` gate named `o1` with a rise time delay of 2 time units and a fall time delay of 3 time units, connecting inputs `a` and `b` to the output `out1`.\n- `bufifo` gate named `b1` with a rise time delay of 4 time units and a fall time delay of 5 time units, connecting inputs `a` and `b` to the output `out2`.", "verilog": "module des ( input a, b, \n             output out1, out2);\n\n    // AND gate with delays on rise and fall\n    and    #(2, 3) o1 (out1, a, b);\n\n    // BUFIFO gate with delays on rise and fall\n    bufifo #(4, 5) b1 (out2, a, b);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out1, out2;\n\n    // Instantiate the DUT (Device Under Test)\n    top d0 (\n        .out1(out1), \n        .out2(out2), \n        .a(a), \n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t a=%b b=%b and=%b bufifo=%b\", $time, a, b, out1, out2); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 a = 1; // Set a to 1 after 10 time units\n        #10 b = 1; // Set b to 1 after 20 time units\n        #10 a = 0; // Set a to 0 after 30 time units\n        #10 b = 0; // Set b to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_14", "task_recommend": "This Verilog module, named `des`, features two gates, with each gate having specified delays:\n- `and` gate named `o1` with a rise time delay of 2 time units and a fall time delay of 3 time units, connecting inputs `a` and `b` to the output `out1`.\n- `bufifo` gate named `b1` with a rise time delay of 5 time units, a fall time delay of 6 time units, and a turn-off delay of 7 time units, connecting inputs `a` and `b` to the output `out2`.", "verilog": "module des ( input a, b, \n             output out1, out2);\n\n    // AND gate with specified rise and fall delays\n    and    #(2, 3) o1 (out1, a, b);\n\n    // BUFIFO gate with specified rise, fall, and turn-off delays\n    bufifo #(5, 6, 7) b1 (out2, a, b);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out1, out2;\n\n    // Instantiate the DUT (Device Under Test)\n    top d0 (\n        .out1(out1), \n        .out2(out2), \n        .a(a), \n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t a=%b b=%b and=%b bufifo=%b\", $time, a, b, out1, out2); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 a = 1; // Set a to 1 after 10 time units\n        #10 b = 1; // Set b to 1 after 20 time units\n        #10 a = 0; // Set a to 0 after 30 time units\n        #10 b = 0; // Set b to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_15", "task_recommend": "the `des` module includes two gates, each with delays defined for three scenarios: minimum, typical, and maximum. These values reflect variations in delay times due to differences in manufacturing, temperature, or other environmental conditions:\n\n- The `and` gate (`o1`) has rise and fall delays specified as `2:3:4` and `3:4:5`, respectively. These values represent minimum, typical, and maximum delays.\n- The `bufifo` gate (`b1`) has rise, fall, and turn-off delays specified as `5:6:7`, `6:7:8`, and `7:8:9`, respectively.", "verilog": "module des ( input a, b, \n             output out1, out2);\n\n    // AND gate with min, typical, and max rise and fall delays\n    and #(2:3:4, 3:4:5) o1 (out1, a, b);\n\n    // BUFIFO gate with min, typical, and max rise, fall, and turn-off delays\n    bufifo #(5:6:7, 6:7:8, 7:8:9) b1 (out2, a, b);\n\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out1, out2;\n\n    // Instantiate the DUT (Device Under Test)\n    top d0 (\n        .out1(out1), \n        .out2(out2), \n        .a(a), \n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t a=%b b=%b and=%b bufifo=%b\", $time, a, b, out1, out2); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 a = 1; // Set a to 1 after 10 time units\n        #10 b = 1; // Set b to 1 after 20 time units\n        #10 a = 0; // Set a to 0 after 30 time units\n        #10 b = 0; // Set b to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_16", "task_recommend": "the use of switch-level modeling in Verilog using NMOS and PMOS transistors. Each transistor is defined with control and data inputs, and the module `des` outputs through these transistors depending on the logic level of the inputs.", "verilog": "module des (input d, ctrl, output outn, outp);\n    nmos (outn, d, ctrl);  // NMOS transistor\n    pmos (outp, d, ctrl);  // PMOS transistor\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg d, ctrl;\n    wire outn, outp;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .d(d), \n        .ctrl(ctrl), \n        .outn(outn), \n        .outp(outp)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {d, ctrl} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t d=%0b ctrl=%0b outn=%0b outp=%0b\", $time, d, ctrl, outn, outp); // Monitor signal changes\n        \n        // Sequential stimulus to change input values\n        #10 d = 1;       // Set d to 1 after 10 time units\n        #10 ctrl = 1;    // Set ctrl to 1 after 20 time units\n        #10 d = 0;       // Set d to 0 after 30 time units\n        #10 ctrl = 0;    // Set ctrl to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_17", "task_recommend": "The use of CMOS switches in Verilog. The `cmos` primitive gate is used to model a complementary MOS transistor, controlled by both `nctrl` and `pctrl` signals.", "verilog": "module des (input d, nctrl, pctrl, output out);\n    cmos (out, d, nctrl, pctrl);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg d, nctrl, pctrl;\n    wire out;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .d(d), \n        .nctrl(nctrl), \n        .pctrl(pctrl), \n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {d, nctrl, pctrl} = 3'b000; // Initialize inputs to 0\n        $monitor(\"T=%0t d=%0b nctrl=%0b pctrl=%0b out=%0b\", $time, d, nctrl, pctrl, out); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 d = 1;        // Set d to 1 after 10 time units\n        #10 nctrl = 1;    // Set nctrl to 1 after 20 time units\n        #10 pctrl = 1;    // Set pctrl to 1 after 30 time units\n        #10 nctrl = 0;    // Set nctrl to 0 after 40 time units\n        #10 pctrl = 0;    // Set pctrl to 0 after 50 time units\n        #10 d = 0;        // Set d to 0 after 60 time units\n        #10;              // Wait for an additional 10 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_18", "task_recommend": "The use of a bidirectional switch (`tran`) in Verilog. The `tran` gate allows signal transmission between `io1` and `io2` based on the state of `ctrl`.", "verilog": "module des (input io1, ctrl, output io2);\n    tran (io1, io2);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg io1, ctrl;\n    wire io2;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .io1(io1), \n        .ctrl(ctrl), \n        .io2(io2)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {io1, ctrl} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t io1=%0b ctrl=%0b io2=%0b\", $time, io1, ctrl, io2); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 io1 = 1;   // Set io1 to 1 after 10 time units\n        #10 ctrl = 1;  // Set ctrl to 1 after 20 time units\n        #10 ctrl = 0;  // Set ctrl to 0 after 30 time units\n        #10 io1 = 0;   // Set io1 to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_19", "task_recommend": "The use of the `tranif0` switch in Verilog. The `tranif0` switch is a type of transmission gate that only connects its terminals when the control signal (`ctrl`) is low (`0`). In this module, `io1` and `io2` are connected through the `tranif0` switch based on the state of `ctrl`. When `ctrl` is `0`, `io1` and `io2` are electrically connected, and when `ctrl` is not `0`, the connection between `io1` and `io2` is broken. This can be used for creating conditional connectivity in a circuit.", "verilog": "module des (input io1, ctrl, output io2);\n    tranif0 (io1, io2, ctrl);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg io1, ctrl;\n    wire io2;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .io1(io1), \n        .ctrl(ctrl), \n        .io2(io2)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {io1, ctrl} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t io1=%0b ctrl=%0b io2=%0b\", $time, io1, ctrl, io2); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 io1 = 1;   // Set io1 to 1 after 10 time units\n        #10 ctrl = 1;  // Set ctrl to 1 after 20 time units\n        #10 ctrl = 0;  // Set ctrl to 0 after 30 time units\n        #10 io1 = 0;   // Set io1 to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_2", "task_recommend": "Create a module that implements a AND gate, two inputs and one output.", "verilog": "module gates ( input a,\n               output b);\n   buf (b, a);  // b is the output, a is input\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a;\n    wire b;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a),\n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        a = 0; // Initialize input\n        $monitor(\"T=%t a=%b  b(buf)=%b\", $time, a, b); // Monitor signal changes\n\n        // Generate random values for 'a'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_20", "task_recommend": "The use of the `tranif1` switch in Verilog. The `tranif1` switch is a type of transmission gate that only connects its terminals when the control signal (`ctrl`) is high (`1`). In this module, `io1` and `io2` are connected through the `tranif1` switch based on the state of `ctrl`. When `ctrl` is `1`, `io1` and `io2` are electrically connected, and when `ctrl` is not `1` (i.e., low), the connection between `io1` and `io2` is broken. This allows for conditional connectivity based on the control signal.", "verilog": "module des (input io1, ctrl, output io2);\n    tranif1 (io1, io2, ctrl);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg io1, ctrl;\n    wire io2;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .io1(io1), \n        .ctrl(ctrl), \n        .io2(io2)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {io1, ctrl} = 2'b00; // Initialize inputs to 0\n        $monitor(\"T=%0t io1=%0b ctrl=%0b io2=%0b\", $time, io1, ctrl, io2); // Monitor signal changes\n\n        // Sequential stimulus to change input values\n        #10 io1 = 1;   // Set io1 to 1 after 10 time units\n        #10 ctrl = 1;  // Set ctrl to 1 after 20 time units\n        #10 ctrl = 0;  // Set ctrl to 0 after 30 time units\n        #10 io1 = 0;   // Set io1 to 0 after 40 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_21", "task_recommend": "The use of `supply1` and `supply0` to define power (`VDD`) and ground (`GND`) signals within a module. The `supply1` and `supply0` primitives provide a constant logic high (`1`) and low (`0`), respectively, which are then assigned to the module outputs `vdd` and `gnd`.", "verilog": "module des (output vdd, output gnd);\n    supply1 _vdd;\n    supply0 _gnd;\n    assign vdd = _vdd;\n    assign gnd = _gnd;\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg vdd, gnd;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .vdd(vdd), \n        .gnd(gnd)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        // Initialize signals\n        vdd = 1'b0;\n        gnd = 1'b1;\n\n        #10; // Wait for 10 time units\n\n        $display(\"T=%0t vdd=%0d gnd=%0d\", $time, vdd, gnd); // Display the current values of vdd and gnd\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_22", "task_recommend": "Create a module with one input and one output that behaves like a wire.", "verilog": "module top_module( input in, output out );\n    assign out = in;\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg in;\n    wire out;\n\n    // Instantiate the DUT (Device Under Test)\n    top uut (\n        .in(in),\n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        $monitor(\"Time = %0t, in = %b, out = %b\", $time, in, out); // Monitor signal changes\n\n        // Apply stimulus to the input\n        in = 0; #10;  // Set in to 0, wait for 10 time units\n        in = 1; #10;  // Set in to 1, wait for 10 time units\n        in = 0; #10;  // Set in to 0, wait for 10 time units\n        in = 1; #10;  // Set in to 1, wait for 10 time units\n\n        $finish; // Terminate the simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_23", "task_recommend": "The use of the system function `$clog2` to dynamically determine the number of bits needed for an input based on a parameter `NUM_UNITS`. The module `des` is parameterized to adjust to different numbers of units without manually changing the bit width of `active_unit`. if the design has 7 parallel adders, then the minimum number of bits required to represent all 7 adders is `$clog2` of 7 that yields 3.", "verilog": "module des\n    #(parameter NUM_UNITS = 7)\n    // Use of this system function helps to reduce the\n    // number of input wires to this module\n    (input [$clog2(NUM_UNITS)-1:0] active_unit);\n\n    initial\n        $monitor(\"active_unit = %d\", active_unit);\nendmodule\n", "test": "`timescale 1ns/1ns\n`define NUM_UNITS 5\n\nmodule tb;\n    // Signal Declarations\n    integer i;\n    reg [`NUM_UNITS-1:0] active_unit;\n\n    // Instantiate the DUT (Device Under Test) with parameter NUM_UNITS\n    top #(.NUM_UNITS(`NUM_UNITS)) u0 (\n        .active_unit(active_unit)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        active_unit = 1;     // Initialize active_unit to 1\n        #10 active_unit = 7; // Change active_unit to 7 after 10 time units\n        #10 active_unit = 8; // Change active_unit to 8 after 20 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_24", "task_recommend": "Given an 8-bit input vector [7:0], reverse its bit ordering.", "verilog": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\tassign out = {in[0], in[1], in[2], in[3], in[4], in[5], in[6], in[7]};\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg [7:0] in;\n    wire [7:0] out;\n\n    // Instantiate the DUT (Device Under Test)\n    top uut (\n        .in(in),\n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        $monitor(\"Time=%0t | in=%b | out=%b\", $time, in, out); // Monitor signal changes\n\n        // Apply test cases\n        in = 8'b10101010; #10; // Test Case 1\n        in = 8'b11001100; #10; // Test Case 2\n        in = 8'b11110000; #10; // Test Case 3\n        in = 8'b00001111; #10; // Test Case 4\n\n        $finish; // Terminate simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GP_25", "task_recommend": "Output \"Hello,World!\" by designing a Verilog module.", "verilog": "module hello_world;\n\n    initial begin\n        $display(\"Hello World!\");  \n        $finish;  \n    end\n\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Initial block to display \"Hello World!\"\n    initial begin\n        $display(\"Hello World!\");  // Print message to the console\n        $finish;  // Terminate simulation\n    end\n\n    // Initial block for VCD dump\n    initial begin\n        $dumpfile(\"tb.vcd\");  // Specify the VCD file name\n        $dumpvars(0, tb);  // Capture all signals in the testbench module\n    end\n\nendmodule\n"}
{"task_id": "GP_3", "task_recommend": "Create a module that implements a AND gate, two inputs and one output.", "verilog": "module gates (input a, b, output c, d, e);\n    and (c, a, b);  // AND gate: c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire c;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c(and)=%b\", $time, a, b, c); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_4", "task_recommend": "Create a module that implements a OR gate, two inputs and one output.", "verilog": "module gates (input a, b, output c);\n    or  (c, a, b);  // OR gate: c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire c;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c(or)=%b\", $time, a, b, c); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_5", "task_recommend": "Create a module that implements a XOR gate, two inputs and one output.", "verilog": "module gates (input a, b, output c);\n    xor  (c, a, b);  // XOR gate: c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire c;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c(xor)=%b\", $time, a, b, c); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_6", "task_recommend": "Create a module that implements a NAND gate, two inputs and one output.", "verilog": "module gates ( input a, b,\n               output c);\n    // in this example\n    nand (c, a, b);  // c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire c;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c(nand)=%b \", $time, a, b, c); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_7", "task_recommend": "Create a module that implements a NOR gate, two inputs and one output.", "verilog": "module gates ( input a, b,\n               output c);\n    // in this example\n    nor (c, a, b);  // c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire c;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c(nor)=%b \", $time, a, b, c); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin \n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_8", "task_recommend": "Create a module that implements a NXOR gate, two inputs and one output.", "verilog": "module gates ( input a, b,\n               output c);\n    // in this example\n    nxor (c, a, b);  // c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire c;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 2'b00; // Initialize inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c(nxor)=%b\", $time, a, b, c); // Monitor signal changes\n\n        // Generate random values for 'a' and 'b'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GP_9", "task_recommend": "Create a module that implements a AND gate, Four inputs and one output.", "verilog": "module gates ( input a, b, c, d,\n               output e);\n    // in this example\n    and (e, a, b, c, d);  // c is the output, a and b are inputs\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, c, d;\n    wire e;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c), \n        .d(d), \n        .e(e)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b, c, d} = 4'b0000; // Initialize all inputs to 0\n\n        $monitor(\"T=%t a=%b b=%b c=%b d=%b e(and)=%b\", $time, a, b, c, d, e); // Monitor signal changes\n\n        // Generate random values for 'a', 'b', 'c', and 'd'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random values to 'a'\n               b = $random; // Assign random values to 'b'\n               c = $random; // Assign random values to 'c'\n               d = $random; // Assign random values to 'd'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GS_1", "task_recommend": "Design a Verilog module named Mux_21 that implements a 2:1 multiplexer. The multiplexer accepts two input signals a and b and a select signal s. Depending on the value of the select signal s, the corresponding input signal is transmitted to the output y.", "verilog": "module Mux_21(a, b, y, s);\n    input a, b, s;\n    output y;\n\n    assign y = s ? b : a;  // If s is 1, y = b; if s is 0, y = a\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire y;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .a(a), \n        .b(b), \n        .y(y)\n    );\n\n    integer i;\n\n    // Testbench Stimulus\n    initial begin\n        // Apply all combinations of inputs a and b\n        for(i = 0; i < 4; i = i + 1) begin\n            {a, b} = i; // Assign i to {a, b}\n            #10; // Wait for 10 time units\n        end\n    end\n\n    // Monitor changes\n    initial begin\n        $monitor(\"Time = %0t | a = %b | b = %b | y = %b\", $time, a, b, y);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GS_10", "task_recommend": "A multiplexer or **mux** in short, is a digital element that transfers data from one of the N inputs to the output based on the select signal. The case shown below is when N equals 4. For example, a 4 bit multiplexer would have N inputs each of 4 bits where each input can be transferred to the output by the use of a select signal.", "verilog": "module mux_4to1_assign (input [3:0] a, input [3:0] b, input [3:0] c, input [3:0] d, input [1:0] sel, output [3:0] out);\n    // When sel[1] is 0, (sel[0] ? b : a) is selected and when sel[1] is 1, (sel[0] ? d : c) is taken\n    // When sel[0] is 0, a is sent to output, else b and when sel[0] is 0, c is sent to output, else d\n    assign out = sel[1] ? (sel[0] ? d : c) : (sel[0] ? b : a);\nendmodule\n", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Declare internal reg variables to drive design inputs\n    reg [3:0] a;\n    reg [3:0] b;\n    reg [3:0] c;\n    reg [3:0] d;\n    reg [1:0] sel;\n    wire [3:0] out;\n    integer i;\n\n    // Instantiate the 4-to-1 multiplexer design (DUT)\n    top mux0 (\n        .a(a), \n        .b(b), \n        .c(c), \n        .d(d), \n        .sel(sel), \n        .out(out)\n    );\n\n    // Stimulus block\n    initial begin\n        // Launch a monitor to display values whenever a, b, c, d, sel, or out changes\n        $monitor(\"T=%0t | sel=%0h | a=%0h | b=%0h | c=%0h | d=%0h | out=%0h\", \n                 $time, sel, a, b, c, d, out);\n        \n        // 1. At time 0, drive random values to a, b, c, d and keep sel = 0\n        sel = 0;\n        a = $random;\n        b = $random;\n        c = $random;\n        d = $random;\n        \n        // 2. Change the value of sel every 5ns\n        for (i = 1; i < 4; i = i + 1) begin\n            #5 sel = i;\n        end\n        \n        // 3. Wait for 5ns and finish the simulation\n        #5 $finish;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_11", "task_recommend": "Verilog Code for 32-bit Bus Signal Checker:This task requires creating a Verilog module that checks the signal on a 32-bit bus input and outputs a signal based on the sel input. When sel is high, the module outputs check as high if the bus value is 1 (valid signal). When sel is low, the module outputs check as low if the bus value is 0 (invalid signal).\n\nInputs:\n- bus: 32-bit bus input (wire)\n- sel: Selection signal (wire)\n- clk: Clock signal (wire)\n\nOutput:\n- check: Check signal output (wire)", "verilog": "`timescale 1ns/1ns\n \nmodule odd_sel(\n\tinput  [31:0]  bus,\n\tinput          sel,\n\toutput         check\n);\n//*************code***********//\nwire       odd_even;\n \nassign odd_even = ^bus; \nassign check = sel ? odd_even : ~odd_even;\n \n//*************code***********//\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  [31:0] bus;\n    reg         sel;\n    wire        check;\n\n    // Stimulus block\n    initial begin\n        // Initial values\n        bus = 32'd0;\n        sel = 1'b1;\n        #20 bus = 32'd1; sel = 1'b1;\n        #20 bus = 32'd2; sel = 1'b0;\n        #20 bus = 32'd3; sel = 1'b1;\n        #20 bus = 32'd4; sel = 1'b0;\n        #20 bus = 32'd5; sel = 1'b0;\n        #20 bus = 32'd6; sel = 1'b0;\n        #20 bus = 32'd7; sel = 1'b1;\n        #20 bus = 32'd8; sel = 1'b1;\n        #20 bus = 32'd9; sel = 1'b0;\n        #20 bus = 32'd10; sel = 1'b0;\n    end\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_odd_sel (\n        .bus(bus),\n        .sel(sel),\n        .check(check)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GS_12", "task_recommend": "A Verilog module named EvenParity that implements an even parity generator. The parity generator accepts three input signals A, B, and C and generates an output signal out based on the values of the input signals, which represents the even parity bit of the input signals.", "verilog": "module EvenParity(A, B, C, out);\n    input A, B, C;\n    output reg out;\n\n    always @(A, B, C) begin\n        out = A ^ B ^ C;  // XOR for even parity\n    end\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg A, B, C;\n    wire out;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .A(A), \n        .B(B), \n        .C(C), \n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        // Loop through all possible combinations of A, B, and C\n        for (i = 0; i < 8; i = i + 1) begin\n            {A, B, C} = i; // Assign each bit of i to A, B, and C\n            #10; // Wait for 10 time units\n        end\n    end\n\n    // Monitor Signal Changes\n    initial begin\n        $monitor(\"Time=%0t | A=%b B=%b C=%b | out=%b\", $time, A, B, C, out);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_13", "task_recommend": "This module implements an 8-bit arithmetic unit where the output c is determined based on a 2-bit select signal. Depending on the select value, the module performs different operations on the 8-bit inputs a and b.\n\nInputs:\n- clk: Clock signal (wire)\n- rst_n: Active low reset signal (wire)\n- a: 8-bit input signal (wire)\n- b: 8-bit input signal (wire)\n- select: 2-bit select signal (wire)\n\nOutput:\n- c: 8-bit output signal (reg)", "verilog": "`timescale 1ns/1ns\nmodule data_select(\n\tinput clk,\n\tinput rst_n,\n\tinput signed[7:0]a,\n\tinput signed[7:0]b,\n\tinput [1:0]select,\n\toutput reg signed [8:0]c\n);\n\nalways @ (posedge clk or negedge rst_n) begin\n    if(!rst_n) begin\n        c<=9'b0;\n    end\n    else begin\n        case(select)\n\t\t\t2'b00:begin c<=a; end\n\t\t\t2'b01:begin c<=b; end\n\t\t\t2'b10:begin c<=a+b; end\n\t\t\t2'b11:begin c<=a-b; end\n\t\tendcase\n    end\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg                clk;\n    reg                rst_n;\n    reg  signed [7:0]  a, b;\n    reg         [1:0]  select;\n    wire signed [8:0]  c;\n\n    // Instantiate the DUT (Device Under Test)\n    top dut_inst (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b),\n        .select(select),\n        .c(c)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Generate clock with a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 1'b1;\n        rst_n = 1'b0;  // Assert reset\n        a = 8'b10110011;  // Initialize 'a' with a signed value\n        b = 8'b00111000;  // Initialize 'b' with a signed value\n        #10 rst_n = 1'b1;  // Release reset after 10 time units\n\n        // Run the simulation for 200 time units\n        #200 $finish;\n    end\n\n    // Randomly Change 'select' Every 5 Time Units\n    always #5 select = {$random} % 4;\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_14", "task_recommend": "This module compares two 8-bit unsigned numbers a and b. If a is greater than b, it outputs a - b. If a is less than or equal to b, it outputs b - a.\n\nInputs:\n- clk: Clock signal (wire)\n- rst_n: Active low reset signal (wire)\n- a: 8-bit unsigned input signal (wire)\n- b: 8-bit unsigned input signal (wire)\n\nOutput:\n- c: 8-bit unsigned output signal (reg)", "verilog": "`timescale 1ns/1ns\n \nmodule data_minus(\n\tinput              clk,\n\tinput              rst_n,\n\tinput      [7:0]   a,\n\tinput      [7:0]   b,\n\toutput reg [7:0]   c\n);\n \nalways @(posedge clk or negedge rst_n) begin\n\tif (!rst_n) begin\n\t\tc <= 9'd0;\n\tend\n\telse if (a > b) begin\n\t\tc <= a - b;\n\tend\n\telse begin\n\t\tc <= b - a;\n\tend\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  clk;\n    reg  rst_n;\n    reg  [7:0] a;\n    reg  [7:0] b;\n    wire [7:0] c;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_data_minus (\n        .clk(clk),\n        .rst_n(rst_n),\n        .a(a),\n        .b(b),\n        .c(c)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Generate clock with a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 1'b1;\n        rst_n = 1'b0;  // Assert reset\n        #20 rst_n = 1'b1;  // Release reset after 20 time units\n\n        // Run the simulation for a total of 100 time units after reset\n        #100 $finish;\n    end\n\n    // Randomly change 'a' and 'b' every 5 time units\n    always #5 a = {$random} % 256;\n    always #5 b = {$random} % 256;\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GS_15", "task_recommend": "The module includes several similar continuous assignment statements. The goal is to rewrite the code using the generate...for statement to simplify the implementation.\n\nmodule template_module(\n    input [7:0] data_in,\n    output [7:0] data_out\n);\n\n    assign data_out[0] = data_in[7];\n    assign data_out[1] = data_in[6];\n    assign data_out[2] = data_in[5];\n    assign data_out[3] = data_in[4];\n    assign data_out[4] = data_in[3];\n    assign data_out[5] = data_in[2];\n    assign data_out[6] = data_in[1];\n    assign data_out[7] = data_in[0];\n\nendmodule\n\nInputs:\n- data_in: 8-bit unsigned input signal (wire)\n\n- Outputs:\n- data_out: 8-bit unsigned output signal (wire)", "verilog": "`timescale 1ns/1ns\n \nmodule gen_for_module( \n    input  [7:0]   data_in,\n    output [7:0]   data_out\n);\n \ngenerate\n\tgenvar i;\n\tfor (i=0;i<8;i=i+1) begin\n\t\tassign data_out[i] = data_in[7-i];\n\tend\nendgenerate\n \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n\n    // Signal Declarations\n    reg  [7:0] data_in;\n    wire [7:0] data_out;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_gen_for_module (\n        .data_in(data_in),\n        .data_out(data_out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        data_in = 8'd1;  // Initialize data_in\n        #10 data_in = 8'd2;\n        #10 data_in = 8'd3;\n        #10 data_in = 8'd4;\n        #10 data_in = 8'd5;\n        #10 data_in = 8'd6;\n        #10 data_in = 8'd7;\n        #10 $finish;  // End the simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GS_16", "task_recommend": "Design a Verilog module named dual_port_ram that implements a dual-port random access memory (RAM) with independent read and write addresses. This RAM module supports simultaneous read and write operations on the rising edge of the clock, and can write data from one port while reading data from the other port.", "verilog": "module dual_port_ram(clk,Din,Dout,wr_en,wr_addr,rd_En,rd_addr);\n\tinput [7:0]Din;\n\tinput [3:0]wr_addr;\n\tinput [3:0]rd_addr;\n\tinput wr_en,rd_En,clk;\n\toutput reg [7:0]Dout;\n\treg [7:0] Mem [15:0];\n\talways @(posedge clk)\n\tbegin\n\tif(wr_en)\n\t\tMem[wr_addr]<=Din;\n\tif(rd_En)\n\t\tDout <=Mem[rd_addr];\n\tend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg [7:0] din_tb;\n    reg [3:0] wr_addr_tb;\n    reg [3:0] rd_addr_tb;\n    reg wr_en_tb, rd_en_tb, clk_tb;\n    wire [7:0] dout_tb;\n    integer i, j;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .clk(clk_tb),\n        .din(din_tb),\n        .dout(dout_tb),\n        .wr_en(wr_en_tb),\n        .wr_addr(wr_addr_tb),\n        .rd_en(rd_en_tb),\n        .rd_addr(rd_addr_tb)\n    );\n\n    // Clock Generation\n    always begin\n        clk_tb = 1;\n        #5;\n        clk_tb = 0;\n        #5;\n    end\n\n    // Task to initialize signals\n    task initialize;\n    begin\n        din_tb <= 0;\n        wr_en_tb <= 0;\n        rd_en_tb <= 0;\n        rd_addr_tb <= 0;\n        wr_addr_tb <= 0;\n    end\n    endtask\n\n    // Task to perform write operation\n    task write_operation(input [3:0] a, input [7:0] b);\n    begin\n        @(negedge clk_tb)\n        begin\n            wr_en_tb <= 1'b1;\n            wr_addr_tb <= a;\n            din_tb <= b;\n        end\n        @(negedge clk_tb)\n        wr_en_tb <= 1'b0;  // Disable write after operation\n    end\n    endtask\n\n    // Task to perform read operation\n    task read_operation(input [3:0] c);\n    begin\n        @(negedge clk_tb)\n        begin\n            rd_en_tb <= 1'b1;\n            rd_addr_tb <= c;\n        end\n        @(negedge clk_tb)\n        rd_en_tb <= 1'b0;  // Disable read after operation\n    end\n    endtask\n\n    // Main initial block to run the test sequence\n    initial begin\n        initialize;\n\n        // Write data to all addresses\n        for (i = 0; i < 16; i = i + 1) begin\n            write_operation(i, i);\n        end\n\n        // Allow some time after writes\n        #10;\n\n        // Read data from all addresses\n        for (j = 0; j < 16; j = j + 1) begin\n            read_operation(j);\n        end\n\n        #100;\n        $finish;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_17", "task_recommend": "Even frequency division, to realize the clock divided by 4, only needs the counter to count from 0 to 3, and then the output clock will flip when counting to 1 and 3.", "verilog": "module freq_div_even(\n\tinput       clk,\n\tinput       rst,\n\toutput reg  clk_out\n\t);\nreg  [1:0]   cnt;\n \nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tcnt <= 'd0;\n\tend\n\telse if (cnt == 'd3) begin\n\t\tcnt <= 'd0;\n\tend\n\telse begin\n\t\tcnt <= cnt + 'd1;\n\tend\nend\n \nalways @(posedge clk or posedge rst) begin\n\tif (rst) begin\n\t\tclk_out <= 'd0;\n\tend\n\telse if (cnt == 'd1) begin\n\t\tclk_out <= 'd1;\n\tend\n\telse if (cnt == 'd3) begin\n\t\tclk_out <= 'd0;\n\tend\n\telse begin\n\t\tclk_out <= clk_out;\n\tend\nend\nendmodule", "test": "`timescale 10ps / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk;\n    reg rst;\n    wire clk_out;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_freq_div_even (\n        .clk(clk),\n        .rst(rst),\n        .clk_out(clk_out)\n    );\n\n    // Clock Generation\n    always #10 clk = ~clk;  // Generate clock with a period of 20 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 1'b0;   // Initialize clock\n        rst = 1'b1;   // Assert reset\n        #20 rst = 1'b0;  // Release reset after 20 time units\n\n        // Run the simulation for a sufficient period\n        #200 $finish;  // End simulation after 200 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_18", "task_recommend": "Convert binary code to Gray code", "verilog": "module bin2gray#(\t\n\tparameter  DATA_WIDTH  =  'd8\n\t)(\n\tinput   [DATA_WIDTH-1:0]    bin_code,\n\toutput  [DATA_WIDTH-1:0]    gray_code   \n\t);\ngenerate\n\tgenvar i;\n\tfor (i=0;i<DATA_WIDTH-1;i=i+1) begin\n\t\tassign gray_code[i] = bin_code[i+1] ^ bin_code[i];\n\tend\nendgenerate\nassign gray_code[DATA_WIDTH-1] = bin_code[DATA_WIDTH-1];\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n\n    // Signal Declarations\n    reg  [7:0] bin_code_in;\n    wire [7:0] gray_code_out;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n   top #(\n        .DATA_WIDTH(8)\n    ) inst_bin2gray (\n        .bin_code(bin_code_in),\n        .gray_code(gray_code_out)\n    );\n\n    // Stimulus to test the module\n    initial begin\n        // Loop through all 8-bit binary numbers\n        for (i = 0; i < 256; i = i + 1) begin\n            bin_code_in = i;  // Apply input\n            #20;              // Wait for 20 time units\n        end\n        $finish;  // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "GS_19", "task_recommend": "Convert Gray code to binary code", "verilog": "module gray2bin#(\n\tparameter  DATA_WIDTH  =  'd8\n\t)(\n\tinput   [DATA_WIDTH-1:0]    gray_code,\n\toutput  [DATA_WIDTH-1:0]    bin_code   \n\t);\ngenerate\n\tgenvar i;\n\tfor (i=0;i<DATA_WIDTH-1;i=i+1) begin\n\t\tassign bin_code[i] = bin_code[i+1] ^ gray_code[i];\n\tend\nendgenerate\nassign bin_code[DATA_WIDTH-1] = gray_code[DATA_WIDTH-1];\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n\n    // Signal Declarations\n    reg  [7:0] bin_code_in;\n    wire [7:0] gray_code_out;\n    wire [7:0] bin_code_out;\n    integer i;\n\n    // Instantiate the gray2bin module (DUT)\n    top #(\n        .DATA_WIDTH(8)\n    ) inst_gray2bin (\n        .gray_code(gray_code_out),\n        .bin_code(bin_code_out)\n    );\n\n    // Stimulus to test the modules\n    initial begin\n        // Loop through all 8-bit binary numbers\n        for (i = 0; i < 256; i = i + 1) begin\n            bin_code_in = i;  // Apply input\n            #20;              // Wait for 20 time units\n        end\n        $finish;  // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule"}
{"task_id": "GS_2", "task_recommend": "Defines a full adder (`fa`) module, which computes the sum and carry-out of three input bits (a, b, and cin).", "verilog": "module fa (input a, b, cin,\n           output sum, cout);\n    wire s1, net1, net2;\n\n    xor (s1, a, b);\n    xor (net1, a, b);\n    xor (sum, s1, cin);\n    and (net2, s1, cin);\n    xor (cout, net1, net2);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, cin;\n    wire sum, cout;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .cin(cin), \n        .sum(sum), \n        .cout(cout)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b, cin} = 3'b000; // Initialize inputs to 0\n        $monitor(\"T=%0t | a=%b | b=%b | cin=%b | cout=%b | sum=%b\",\n                 $time, a, b, cin, cout, sum);\n\n        // Generate random values for 'a', 'b', and 'cin'\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random % 2;  // Assign random binary values to 'a'\n               b = $random % 2;  // Assign random binary values to 'b'\n               cin = $random % 2; // Assign random binary values to 'cin'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_20", "task_recommend": "Design a Verilog module called Alu that can perform a variety of operations and logic violations. The main function of this module is to perform different operations according to the input selection signal and output the results to y.", "verilog": "module Alu(a,b,s,y);\ninput [3:0]a,b,s;\noutput reg [3:0]y;\nalways@(*)\nbegin\ncase(s)\n\t4'b0000:y=a+b;//Addition\n\t4'b0001:y=a-b;//Substraction\n\t4'b0010:y=a*b;//Multipiler\n\t4'b0011:y=a/b;//Division\n\t4'b0100:y=a%b;//Modulo\n\t4'b0101:y=~a;//not a\n\t4'b0110:y=!b;//not b\n\t4'b0111:y=a^b;//xor\n\t4'b1000:y=~(a|b);//nor\n\t4'b1001:y=~(a^b);//xnor\n\t4'b1010:y=a**b;//square\n\t4'b1011:y=a&b;//and\n\t4'b1100:y=a|b;//or\n\t4'b1101:y=a+1;//increment\n\t4'b1110:y=a-1;//decrement\n\t4'b1111:y=!(a&b);//nand\n\tdefault:y=4'bzzz;\nendcase\nend\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg [3:0] a, b, s;\n    wire [3:0] y;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .a(a), \n        .b(b), \n        .s(s), \n        .y(y)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        a = 4'b1100; // Set A to 12\n        b = 4'b0010; // Set B to 2\n\n        // Loop through all values of 's' to test different ALU operations\n        for (i = 0; i < 16; i = i + 1) begin\n            s = i;   // Assign 's' to the loop index\n            #10;     // Wait for 10 time units for each operation\n        end\n    end\n\n    // Monitor Output\n    initial begin\n        $monitor(\"Time=%0t | S=%d | A=%d | B=%d | Output=%d\", $time, s, a, b, y);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_21", "task_recommend": "Design a Verilog module named Full_Subtractor, which is used to implement a 1-bit full subtractor function. The full subtractor accepts three input bits: the minuend a, the subtrahend b, and the borrow bit c of the previous bit, and outputs the difference value difference and the borrow bit barrow of the current bit.", "verilog": "module Full_Substractor(a,b,c,barrow,difference);\ninput a,b,c;\noutput reg barrow,difference;\nalways@(a,b,c)\nbegin\n\tdifference<=a^b^c;\n\tbarrow<=(a&(~b))+(a&c)+((~b)&c);\nend\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, c;\n    wire barrow, difference;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .a(a), \n        .b(b), \n        .c(c), \n        .barrow(barrow), \n        .difference(difference)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        // Loop through all combinations of a, b, and c (3-bit)\n        for (i = 0; i < 8; i = i + 1) begin\n            {a, b, c} = i;  // Assign i to a, b, c (3-bit representation)\n            #10;            // Wait for 10 time units\n        end\n    end\n\n    // Monitor Output\n    initial begin\n        $monitor(\"Time=%0t | A=%b | B=%b | C=%b | Difference=%b | Barrow=%b\", \n                 $time, a, b, c, difference, barrow);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_22", "task_recommend": "Design a Verilog module named mod11 that implements a loadable modulo 11 counter. The counter counts on the rising edge of the clock signal clk and rolls back to 0 when the count reaches 10 (modulo 11 counting). Additionally, the counter can be loaded with a specific value at any time via an external signal.", "verilog": "module mod11(load, load_enable, out, clk, rst);\n    input clk, rst, load_enable;\n    input [3:0] load;\n    output reg [3:0] out;\n\n    always @(posedge clk) begin\n        if (rst == 1)\n            out <= 0;\n        else begin\n            if (load_enable == 1)\n                out <= load;\n            else if (out == 10)\n                out <= 0;\n            else\n                out <= out + 1;\n        end\n    end\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk_tb, rst_tb, load_en_tb;\n    reg [3:0] load_tb;\n    wire [3:0] out_tb;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .load(load_tb), \n        .load_en(load_en_tb), \n        .out(out_tb), \n        .clk(clk_tb), \n        .rst(rst_tb)\n    );\n\n    // Clock Generation\n    always begin\n        clk_tb = 1;\n        #5;\n        clk_tb = 0;\n        #5;\n    end\n\n    // Task to Load Value\n    task load_tsk(input [3:0] a);\n    begin\n        @(negedge clk_tb) begin\n            load_en_tb <= 1;\n            load_tb <= a;\n        end\n        @(negedge clk_tb)\n            load_en_tb <= 0;\n    end\n    endtask\n\n    // Task to Reset\n    task rst_tsk(input b);\n    begin\n        @(negedge clk_tb)\n            rst_tb <= b;\n    end\n    endtask\n\n    // Testbench Stimulus\n    initial begin\n        rst_tsk(1);  // Assert reset\n        #50;\n        rst_tsk(0);  // De-assert reset\n        #50;\n        load_tsk(4'b0001); // Load a value of 1\n        #20;\n        load_tsk(4'b0000); // Load a value of 0\n        #20;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_23", "task_recommend": "Design a Verilog module called bibuffer that implements a bidirectional buffer. This buffer determines the direction of data transfer between the A and B ports through the control signal ctrl. When ctrl is 1, the data from port A is transmitted to port B; when ctrl is 0, the data from port B is transmitted to port A. If the control signal is in another state, no data is transmitted.", "verilog": "module bibuffer(A,B,ctrl);\ninout A,B;\ninput ctrl;\nassign B=(ctrl==1)?A:1'bz;\nassign A=(ctrl==0)?B:1'bz;\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    wire A_tb, B_tb;\n    reg ctrl_tb;\n    reg temp_A, temp_B;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .A(A_tb), \n        .B(B_tb), \n        .ctrl(ctrl_tb)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        ctrl_tb = 1;\n        temp_A = 0;\n        #20;\n        temp_A = 1;\n        #20;\n        ctrl_tb = 0;\n        temp_B = 0;\n        #20;\n        temp_B = 1;\n        #20;\n    end\n\n    // Assign signals based on control input\n    assign A_tb = (ctrl_tb == 1) ? temp_A : 1'bz;\n    assign B_tb = (ctrl_tb == 0) ? temp_B : 1'bz;\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_24", "task_recommend": "A Verilog module named Demux14 that implements a 1:4 demultiplexer. The demultiplexer accepts an input signal din and a 2-bit wide select signal A, and transfers the input signal din to one of the four output signals Y[3:0], which is determined by the select signal A.", "verilog": "module Demux14(output [3:0] Y, input [1:0] A, input din);\n    assign Y[0] = din & (~A[0]) & (~A[1]);  // When A = 00, Y[0] = din\n    assign Y[1] = din & (~A[1]) & A[0];     // When A = 01, Y[1] = din\n    assign Y[2] = din & A[1] & (~A[0]);     // When A = 10, Y[2] = din\n    assign Y[3] = din & A[1] & A[0];        // When A = 11, Y[3] = din\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg din;\n    reg [1:0] s;\n    wire [3:0] y;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .y(y),\n        .s(s),\n        .din(din)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        din = 1;       // Set input din to 1\n        s = 2'b00;     // Start with select input 00\n        #1 s = 2'b01;  // Change select to 01 after 1 time unit\n        #1 s = 2'b10;  // Change select to 10 after 1 time unit\n        #1 s = 2'b11;  // Change select to 11 after 1 time unit\n    end\n\n    // Monitor Outputs\n    initial begin\n        $monitor(\"Time=%0t | Din=%b | S=%b | Y=%b\", $time, din, s, y);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_25", "task_recommend": "A Verilog module named srff, which implements an SR flip-flop (Set-Reset Flip-Flop). The SR flip-flop is a basic storage unit with set (Set), reset (Reset) functions, as well as A Verilog module named srff, which implements an SR flip-flop (Set-Reset Flip-Flop). The SR flip-flop is a basic storage unit with set (Set), reset (Reset) functions, as well as a clock input clk and an asynchronous reset input rst. The outputs are q and qbar, which represent the current state and the inverse of the state respectively.", "verilog": "module srff(s, r, clk, rst, q, qbar);\n    input s, r, clk, rst;\n    output reg q, qbar;\n\n    always @(posedge clk or posedge rst) begin\n        if (rst == 1) begin\n            q <= 0;\n        end else begin\n            case ({s, r})\n                2'b00: q = q;           // No change\n                2'b01: q = 0;           // Reset\n                2'b10: q = 1;           // Set\n                2'b11: q = 1'bz;        // Invalid state (high impedance)\n                default: q <= 1'b0;     // Default case\n            endcase\n            qbar <= ~q;  // qbar is always the complement of q\n        end\n    end\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg s, r, clk, rst;\n    wire q, qbar;\n\n    // Instantiate the DUT (Device Under Test)\n    top DUT (\n        .s(s), \n        .r(r), \n        .clk(clk), \n        .rst(rst), \n        .q(q), \n        .qbar(qbar)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 0;     // Initialize clock to 0\n        rst = 1;     // Assert reset\n        #10 rst = 0; // Deassert reset after 10 time units\n        s = 1'b0; r = 1'b0;  // Initial state: S = 0, R = 0\n        #10 s = 1'b0; r = 1'b1;  // Test state: S = 0, R = 1\n        #10 s = 1'b1; r = 1'b0;  // Test state: S = 1, R = 0\n        #10 s = 1'b1; r = 1'b1;  // Invalid state: S = 1, R = 1\n        #10 $stop;  // Stop simulation\n    end\n\n    // Monitor Outputs\n    initial begin\n        $monitor(\"Time=%0t | clk=%b | rst=%b | S=%b | R=%b | Q=%b | Qbar=%b\", \n                 $time, clk, rst, s, r, q, qbar);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_3", "task_recommend": "Defines a simple 4-to-2 encoder module named `enc_4x2` that takes four inputs (a, b, c, d) and produces two outputs (x, y) using OR gates.", "verilog": "module enc_4x2 ( input a, b, c, d,\n                 output x, y);\n    or (x, b, d);\n    or (y, c, d);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, c, d;\n    wire x, y;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .c(c), \n        .d(d), \n        .x(x), \n        .y(y)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b, c, d} = 4'b0000; // Initialize inputs to 0\n        $monitor(\"T=%0t | a=%b | b=%b | c=%b | d=%b | x=%b | y=%b\",\n                 $time, a, b, c, d, x, y);\n\n        // Apply all combinations of inputs a, b, c, d\n        for (i = 0; i < 16; i = i+1) begin\n            #1 {a, b, c, d} = i; // Assign the integer i to the 4-bit vector {a, b, c, d}\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_4", "task_recommend": "Write a module which implements a 3-stage pipeline. Each stage is a single bit, and there is a single bit as input. The output should be 1 whenever all three stages contain a zero, which is the initial condition.", "verilog": "module zero3 (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg s1, s2, s3;\n\n\tassign out = s1==0 & s2==0 & s3==0;\n\n\tinitial begin\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\ts3 = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\ts1 <= in;\n\t\ts2 <= s1;\n\t\ts3 <= s2;\n\tend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    wire out;\n    reg in, clk;\n\n    // Instantiate the DUT (Device Under Test)\n    top z3 (\n        .out(out), \n        .in(in), \n        .clk(clk)\n    );\n\n    // Clock Generation\n    initial begin\n        in = 0;\n        clk = 0;\n        forever #5 clk = ~clk;  // Generate a clock with a period of 10 time units\n    end\n\n    // Testbench Stimulus\n    initial begin\n        $monitor($time, \" clk: %b  in: %b  out: %b\", clk, in, out); // Monitor signal changes\n\n        // Apply stimulus to the input\n        repeat (2) @(posedge clk); // Wait for 2 positive edges of clk\n        in <= 1;\n        repeat (2) @(posedge clk); // Wait for 2 positive edges of clk\n        in <= 0;\n        repeat (4) @(posedge clk); // Wait for 4 positive edges of clk\n        in <= 1;\n        repeat (3) @(posedge clk) in <= ~in; // Toggle in on each positive edge of clk\n        @(posedge clk) in <= 0;\n        repeat (4) @(posedge clk); // Wait for 4 positive edges of clk\n        \n        #1 $finish; // Terminate simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_5", "task_recommend": "Write the following model as a 0-delay model where all signals change at the rising edge of clk.", "verilog": "module autom (out, in, clk);\n\toutput [3:0] out;\n\tinput in;\n\tinput clk;\n\treg [1:0] state;\n\n\tinitial state = 0;\n\tassign out = state * 5;\n\talways @(posedge clk)\n\t\tcase (state)\n\t0:\t\tstate <= in ? 1 : 0;\n\t1:\t\tstate <= in ? 2 : 1;\n\t2:\t\tstate <= in ? 0 : 2;\n\t\tendcase\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    wire [3:0] out;\n    reg in, clk;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top a1 (\n        .out(out), \n        .in(in), \n        .clk(clk)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Generate a clock signal with a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 0;  // Initialize clock\n        in = 0;   // Initialize input\n        $monitor($time, \" clk: %b  in: %b  out: %d\", clk, in, out); // Monitor signal changes\n\n        #15 in <= 1; // Set 'in' to 1 after 15 time units\n\n        // Toggle 'in' every 10 time units\n        for (i = 0; i < 10; i = i + 1) begin\n            #10 in <= ~in;\n        end\n\n        $finish; // Terminate simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_6", "task_recommend": "Write the following model as a 0-delay model where all signals change at the falling edge of clk.", "verilog": "module autom (out, in, clk);\n    output [3:0] out;\n    input in;\n    input clk;\n    reg [1:0] state;\n\n    initial state = 0;\n    assign out = state * 5;\n    always @(posedge clk)\n        case (state)\n    0:      state = @(negedge clk) in ? 1 : 0;\n    1:      state = @(negedge clk) in ? 2 : 1;\n    2:      state = @(negedge clk) in ? 0 : 2;\n        endcase\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    reg in;\n    reg clk;\n    wire [3:0] out;\n\n    // Instantiate the DUT (Device Under Test)\n    top uut (\n        .out(out),\n        .in(in),\n        .clk(clk)\n    );\n\n    // Clock Generation\n    initial clk = 0;\n    always #10 clk = ~clk;  // Generate a clock with a period of 20 time units\n\n    // Testbench Stimulus\n    initial begin\n        in = 0;   // Initialize input\n        #5;       // Initial delay to stabilize signals\n\n        // Apply test stimulus\n        #20 in = 1;\n        #40 in = 0;\n        #20 in = 1;\n        #20 in = 0;\n        #20 in = 1;\n        #40 in = 0;\n\n        #20 $finish; // Terminate simulation\n    end\n\n    // Monitor Signal Changes\n    initial begin\n        $monitor(\"Time=%t, clk=%b, in=%b, state=%b, out=%b\", $time, clk, in, uut.state, out);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_7", "task_recommend": "The design for a toggle flip-flop (T flip-flop) with an asynchronous reset.", "verilog": "module tff (\n    input clk,       // Clock signal was missing in your port list\n    input rstn,\n    input t,\n    output reg q\n);\n\nalways @(posedge clk or negedge rstn) begin  // Added clk in the sensitivity list for clarity\n    if (!rstn)\n        q <= 0;\n    else if (t)\n        q <= ~q;  // Toggle q if t is high\n    else\n        q <= q;   // Hold current state of q if t is low\nend\n\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    reg clk;\n    reg d;\n    reg rstn;\n    wire q;\n    \n    // Instantiate the D flip-flop (DUT - Device Under Test)\n    top dff0 (\n        .d(d), \n        .rstn(rstn), \n        .clk(clk), \n        .q(q)\n    );\n\n    // Clock Generation\n    initial clk = 0;\n    always #10 clk = ~clk;  // Generate a clock with a period of 20 time units\n\n    // Testcase\n    initial begin\n        d = 0;\n        rstn = 0;\n        #15 d = 1;           // Set d to 1 after 15 time units\n        #10 rstn = 1;        // Release reset after 10 more time units\n\n        // Randomized test stimulus\n        for (int i = 0; i < 20; i = i + 1) begin\n            reg [4:0] dly = $random % 32;  // Random delay between 0 and 31 time units\n            #dly d = $random % 2;          // Randomize d with a binary value (0 or 1)\n        end\n\n        #20 $finish;  // End simulation after final delay\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_8", "task_recommend": "This Verilog module defines a counter that can count up to a specified maximum value N (N=10) before rolling over. The counter width is parameterizable with WIDTH(WIDTH=4), and the counter will reset to 0 when the reset signal rstn is active-low or when it reaches its maximum count value.", "verilog": "module modN_ctr\n#(\n    parameter N = 10,\n    parameter WIDTH = 4\n)\n(\n    input clk,\n    input rstn,\n    output reg[WIDTH-1:0] out\n);\n\nalways @(posedge clk) begin\n    if (!rstn) begin\n        out <= 0;\n    end else begin\n        if (out == N-1)\n            out <= 0;\n        else\n            out <= out + 1;\n    end\nend\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    parameter N = 10;\n    parameter WIDTH = 4;\n\n    reg clk;\n    reg rstn;\n    wire [WIDTH-1:0] out;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .clk(clk),\n        .rstn(rstn),\n        .out(out)\n    );\n\n    // Clock Generation\n    initial clk = 0;\n    always #10 clk = ~clk;  // Generate a clock with a period of 20 time units\n\n    // Testbench Stimulus\n    initial begin\n        {clk, rstn} = 0;  // Initialize signals\n        $monitor(\"T=%0t rstn=%b out=%0xh\", $time, rstn, out);  // Monitor signal changes\n\n        // Test Sequence\n        repeat(2) @(posedge clk);  // Wait for 2 positive clock edges\n        rstn <= 1;  // Release reset\n        repeat(20) @(posedge clk);  // Continue running for 20 more clock edges\n        $finish;  // Terminate simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "GS_9", "task_recommend": "This Verilog module implements a Gray code counter with a parameterizable width. It updates its output based on the clock edge and reset conditions. The output is a Gray code representation of the binary counter q. There are two implementations provided for calculating the Gray code: one uses a for loop and the other uses bitwise operations, which can be toggled using the FOR_LOOP directive.", "verilog": "module gray_ctr #(parameter N = 4) (\n    input clk,\n    input rstn,\n    output reg [N-1:0] out\n);\n\nreg [N-1:0] q;\n\nalways @(posedge clk) begin\n    if (!rstn) begin\n        q <= 0;\n        out <= 0;\n    end else begin\n        q <= q + 1;\n\n        `ifdef FOR_LOOP\n        for (int i = 0; i < N-1; i=i+1) begin\n            out[i] <= q[i+1] ^ q[i];\n        end\n        out[N-1] <= q[N-1];\n        `else\n        out <= {q[N-1], q[N-1:1] ^ q[N-2:0]};\n        `endif\n    end\nend", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n\n    // Parameter Declaration\n    parameter WIDTH = 4; // Width of the Gray code counter\n\n    // Signal Declarations\n    reg clk;\n    reg rstn;\n    wire [WIDTH-1:0] gray_out;\n\n    // Instantiate the DUT (Device Under Test)\n    top #(\n        .WIDTH(WIDTH)\n    ) uut (\n        .clk(clk),\n        .rstn(rstn),\n        .gray_out(gray_out)\n    );\n\n    // Clock Generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk; // Generate a clock with a period of 10 ns\n    end\n\n    // Testbench Stimulus\n    initial begin\n        rstn = 0;            // Initialize reset to 0\n        #15 rstn = 1;        // Release reset after 15 ns\n\n        // Run simulation for a sufficient period to observe counter behavior\n        #100 $finish;        // End simulation after 100 ns\n    end\n\n    // Monitor Signal Changes\n    initial begin\n        $monitor(\"Time: %0t | Reset: %b | Gray Code Output: %b\", $time, rstn, gray_out);\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\n\nendmodule\n"}
{"task_id": "MGA_1", "task_recommend": "This module implements a 4-bit ripple counter using the dff flip-flop described above. Each flip-flop captures the inverted output of the previous stage's output, creating a ripple effect through the counter.", "images": ["MGA_1\\img_99.png"], "verilog": "module dff (\n    input d,\n    input clk,\n    input rstn,\n    output reg q,\n    output qn\n);\nalways @(posedge clk or negedge rstn) begin\n    if (!rstn)\n        q <= 0;\n    else\n        q <= d;\nend\nassign qn = ~q;\nendmodule\n\nmodule ripple (\n    input clk,\n    input rstn,\n    output [3:0] out\n);\nwire q0, qn0;\nwire q1, qn1;\nwire q2, qn2;\nwire q3, qn3;\n\ndff dff0 (.d(qn0), .clk(clk), .rstn(rstn), .q(q0), .qn(qn0));\ndff dff1 (.d(qn1), .clk(q0), .rstn(rstn), .q(q1), .qn(qn1));\ndff dff2 (.d(qn2), .clk(q1), .rstn(rstn), .q(q2), .qn(qn2));\ndff dff3 (.d(qn3), .clk(q2), .rstn(rstn), .q(q3), .qn(qn3));\n\nassign out = {qn3, qn2, qn1, qn0};\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk;\n    reg rstn;\n    wire [3:0] out;\n\n    // Instantiate the ripple counter (Device Under Test)\n    top r0 (\n        .clk(clk), \n        .rstn(rstn), \n        .out(out)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units, creating a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 0;   // Initialize clock\n        rstn = 0;  // Assert reset\n\n        // De-assert reset after 4 clock cycles\n        repeat (4) @(posedge clk);\n        rstn <= 1;\n\n        // Run for 25 clock cycles before finishing simulation\n        repeat (25) @(posedge clk);\n        $finish;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGA_2", "task_recommend": "a ring counter that shifts its contents cyclically with each clock pulse, with the ability to reset to a predefined state.", "images": ["MGA_2\\img_101.png"], "verilog": "module ring_ctr #(parameter WIDTH=4)\n(\n    input clk,\n    input rstn,\n    output reg [WIDTH-1:0] out\n);\n\nalways @(posedge clk) begin\n    if (!rstn) begin\n        out <= 1;  // Initialize output on reset\n    end else begin\n        out[WIDTH-1] <= out[0];  // Shift the last bit to the highest bit\n        for (int i = 0; i < WIDTH-1; i=i+1) begin\n            out[i] <= out[i+1];  // Shift all bits left\n        end\n    end\nend\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Parameter Declaration\n    parameter WIDTH = 4;\n\n    // Signal Declarations\n    reg clk;\n    reg rstn;\n    wire [WIDTH-1:0] out;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .clk(clk), \n        .rstn(rstn), \n        .out(out)\n    );\n\n    // Clock Generation\n    always #10 clk = ~clk;  // Toggle clock every 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        {clk, rstn} = 0;  // Initialize signals\n        $monitor(\"T=%0t | out=%b\", $time, out);  // Monitor output\n\n        repeat (2) @(posedge clk);  // Wait for 2 clock cycles\n        rstn = 1;  // Release reset\n\n        repeat (15) @(posedge clk);  // Run for 15 clock cycles\n        $finish;  // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGA_3", "task_recommend": "This task requires implementing two chained D flip-flops with asynchronous reset functionality.\n\n#### Signal Description:\nInputs:\n- data: Data input (wire),\n- clk: Clock input (wire),\n- rst: Asynchronous reset input (wire)\n\nOutput:\n- q: Output after two stages of flip-flops (reg)\n\nSignal Description:\n\nwave Description:", "images": ["MGA_3\\img_10.png", "MGA_3\\img_9.png"], "verilog": "`timescale 1ns/1ns\nmodule Tff_2 (\ninput wire data, clk, rst,\noutput reg q  \n);\n\nreg q1;\n\nalways @ ( posedge clk or negedge rst)\n\nif (~rst) begin\n  q1 <= 1'b0;\n  q <= 1'b0;\nend \nelse begin\n    if (data) begin\n  \t\tq1 <= !q1;\n\tend\n\tif (q1) begin\n  \t\tq <= !q;\n    end\nend   \nendmodule ", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk;\n    reg rst;    // Active low reset\n    reg data;\n    wire q;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_Tff_2 (\n        .clk(clk),\n        .rst(rst),\n        .data(data),\n        .q(q)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        clk = 1;\n        rst = 0;  // Assert reset (active low)\n        data = 0;\n        #100 rst = 1;  // Release reset after 100 time units\n        #1000 $finish;  // End simulation after 1000 time units\n    end\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units\n\n    // Data Generation\n    always #45 data = ~data;  // Toggle data every 45 time units\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGA_4", "task_recommend": "The table below shows the truth table for a priority encoder. Use Verilog HDL to implement the following priority encoder.\n\n#### Input Description:\n- **Input Signals**:\n  - `I_n[8:0]`\n  - **Type**: `input`\n\n#### Output Description:\n- **Output Signals**:\n  - `Y_n[3:0]`\n  - **Type**: `output reg`", "images": ["MGA_4\\img_24.png"], "verilog": "`timescale 1ns/1ns\n \nmodule encoder_0(\n   input      [8:0]      I_n,\n   output reg [3:0]      Y_n   \n);\n \nalways @(*) begin\n\tcasez(I_n)\n\t\t9'b111111111: begin\n\t\t\tY_n <= 4'b1111;\n\t\tend\n\t\t9'b0????????: begin\n\t\t\tY_n <= 4'b0110;\n\t\tend\n\t\t9'b10???????: begin\n\t\t\tY_n <= 4'b0111;\n\t\tend\n\t\t9'b110??????: begin\n\t\t\tY_n <= 4'b1000;\n\t\tend\n\t\t9'b1110?????: begin\n\t\t\tY_n <= 4'b1001;\n\t\tend\n\t\t9'b11110????: begin\n\t\t\tY_n <= 4'b1010;\n\t\tend\n\t\t9'b111110???: begin\n\t\t\tY_n <= 4'b1011;\n\t\tend\n\t\t9'b1111110??: begin\n\t\t\tY_n <= 4'b1100;\n\t\tend\n\t\t9'b11111110?: begin\n\t\t\tY_n <= 4'b1101;\n\t\tend\n\t\t9'b111111110: begin\n\t\t\tY_n <= 4'b1110;\n\t\tend\n\t\tdefault: begin\n\t\t\tY_n <= 4'bz;\n\t\tend\n\tendcase\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg  [8:0] I_n;\n    wire [3:0] Y_n;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_encoder_0 (\n        .I_n(I_n),\n        .Y_n(Y_n)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        I_n = 9'd0;  // Initialize input to 0\n        #200 $finish;  // End simulation after 200 time units\n    end\n\n    // Generate Random Input Every 10 Time Units\n    always #10 I_n = {$random} % 10'd512;  // Generate a random 9-bit value\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGA_5", "task_recommend": "a 3-8 decoder to implement a full subtractor.The following table is the function table of 8-line to 3-line priority encoder I. Please use Verilog to implement the priority encoder I according to the function table.", "images": ["MGA_5\\img_103.png"], "verilog": "module encoder_83(\n   input       [7:0]      I   ,\n   input                  EI  ,\n   \n   output wire [2:0]      Y   ,\n   output wire            GS  ,\n   output wire            EO    \n);\n \nreg  [2:0]     Y_reg;\n \nalways @(I or EI) begin\n\tif (!EI) begin\n\t\tY_reg = 3'b000;\n\tend\n\telse begin\n\t\tcasez(I)\n\t\t\t8'b00000000: begin\n\t\t\t\tY_reg <= 3'b000;\n\t\t\tend\n\t\t\t8'b1???????: begin\n\t\t\t\tY_reg <= 3'b111;\n\t\t\tend\n\t\t\t8'b01??????: begin\n\t\t\t\tY_reg <= 3'b110;\n\t\t\tend\n\t\t\t8'b001?????: begin\n\t\t\t\tY_reg <= 3'b101;\n\t\t\tend\n\t\t\t8'b0001????: begin\n\t\t\t\tY_reg <= 3'b100;\n\t\t\tend\n\t\t\t8'b00001???: begin\n\t\t\t\tY_reg <= 3'b011;\n\t\t\tend\n\t\t\t8'b000001??: begin\n\t\t\t\tY_reg <= 3'b010;\n\t\t\tend\n\t\t\t8'b0000001?: begin\n\t\t\t\tY_reg <= 3'b001;\n\t\t\tend\n\t\t\t8'b00000001: begin\n\t\t\t\tY_reg <= 3'b000;\n\t\t\tend\n\t\t\tdefault: begin\n\t\t\t\tY_reg <= 3'b000;\n\t\t\tend\n\t\tendcase\n\tend\nend\n \nassign Y  = Y_reg;\nassign GS = (EI==1'b0) ? 1'b0 : (((|I) == 1'b0) ? 1'b0 : 1'b1);\nassign EO = (EI==1'b0) ? 1'b0 : (~GS);\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg   [7:0] I;\n    reg         EI;\n    wire  [2:0] Y;\n    wire        GS;\n    wire        EO;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_encoder_83 (\n        .I(I),\n        .EI(EI),\n        .Y(Y),\n        .GS(GS),\n        .EO(EO)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        I = 8'd0;   // Initialize input to 0\n        EI = 1'b0;  // Initialize enable input to 0\n        #200 $finish;  // End simulation after 200 time units\n    end\n\n    // Generate Random Inputs Every 10 Time Units\n    always #10 I = {$random} % 9'd256;  // Generate a random 8-bit value\n    always #10 EI = {$random} % 2;      // Generate a random 1-bit value\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGA_6", "task_recommend": "Please use basic gate circuits to implement the 3-8 decoder circuit (the truth table is as follows), and use Verilog to describe the circuit. Basic gate circuits include: NOT gate, multi-input AND gate, multi-input OR gate.", "images": ["MGA_6\\img_104.png"], "verilog": "module decoder_38(\n   input             E1_n   ,\n   input             E2_n   ,\n   input             E3     ,\n   input             A0     ,\n   input             A1     ,\n   input             A2     ,\n   \n   output wire       Y0_n   ,  \n   output wire       Y1_n   , \n   output wire       Y2_n   , \n   output wire       Y3_n   , \n   output wire       Y4_n   , \n   output wire       Y5_n   , \n   output wire       Y6_n   , \n   output wire       Y7_n   \n);\n \nassign Y0_n = ~(E3 & (~(E2_n | E1_n | A2 | A1 | A0)));\nassign Y1_n = ~(E3 & A0 & (~(E2_n | E1_n | A2 | A1)));\nassign Y2_n = ~(E3 & A1 & (~(E2_n | E1_n | A2 | A0)));\nassign Y3_n = ~(E3 & A1 & A0 & (~(E2_n | E1_n | A2)));\nassign Y4_n = ~(E3 & A2 & (~(E2_n | E1_n | A1 | A0)));\nassign Y5_n = ~(E3 & A2 & A0 & (~(E2_n | E1_n | A1)));\nassign Y6_n = ~(E3 & A2 & A1 & (~(E2_n | E1_n | A0)));\nassign Y7_n = ~(E3 & A2 & A1 & A0 & (~(E2_n | E1_n)));\ninitial begin\n    $dumpfile(\"tb.vcd\");\n    $dumpvars(0);\nend\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg  E1_n;\n    reg  E2_n;\n    reg  E3;\n    reg  A0;\n    reg  A1;\n    reg  A2;\n    wire Y0_n;\n    wire Y1_n;\n    wire Y2_n;\n    wire Y3_n;\n    wire Y4_n;\n    wire Y5_n;\n    wire Y6_n;\n    wire Y7_n;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_decoder_38 (\n        .E1_n(E1_n),\n        .E2_n(E2_n),\n        .E3(E3),\n        .A0(A0),\n        .A1(A1),\n        .A2(A2),\n        .Y0_n(Y0_n),\n        .Y1_n(Y1_n),\n        .Y2_n(Y2_n),\n        .Y3_n(Y3_n),\n        .Y4_n(Y4_n),\n        .Y5_n(Y5_n),\n        .Y6_n(Y6_n),\n        .Y7_n(Y7_n)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        E1_n = 1'b0;  // Initialize signals\n        E2_n = 1'b0;\n        E3 = 1'b0;\n        A0 = 1'b0;\n        A1 = 1'b0;\n        A2 = 1'b0;\n        #200 $finish;  // End simulation after 200 time units\n    end\n\n    // Random Input Generation Every 10 Time Units\n    always #10 E1_n = {$random} % 2;  // Generate random values for enable and address signals\n    always #10 E2_n = {$random} % 2;\n    always #10 E3 = {$random} % 2;\n    always #10 A0 = {$random} % 2;\n    always #10 A1 = {$random} % 2;\n    always #10 A2 = {$random} % 2;\n\n    // FSDB Dump for Waveform Viewing\n    initial begin\n        $fsdbDumpfile(\"tb_decoder_38.fsdb\");\n        $fsdbDumpvars(0);\n    end\nendmodule\n"}
{"task_id": "MGA_7", "task_recommend": "Based on the state transition table of the finite state machine below, use the state assignment method to implement the synchronous sequential circuit. Write the code in Verilog.\n#### the state transition table\n\n#### Inputs and Outputs\n\n#### Inputs:\n- **input** A,\n- **input** clk,\n- **input** rst_n\n\n#### Output:\n- **output wire** Y", "images": ["MGA_7\\img_29.png", "MGA_7\\img_30.png"], "verilog": "`timescale 1ns/1ns\n \nmodule seq_circuit(\n      input          clk,\n      input          rst_n,\n      input          A,\n      output  wire   Y   \n);\n \nreg  [1:0]    state;\nreg  [1:0]    next_state;\nreg           Y_reg;\n \n//状态机第一段，状态跳转，时序逻辑\nalways @(posedge clk or negedge rst_n) begin\n\tif (!rst_n) begin\n\t\tstate <= 2'b00;\n\tend\n\telse begin\n\t\tstate <= next_state;\n\tend\nend\n//状态机第二段，转移条件，组合逻辑\nalways @(*) begin\n\tnext_state = state;\n\tcase(state)\n\t\t2'b00: begin\n\t\t\tif (A == 1'b1) begin\n\t\t\t\tnext_state <= 2'b11;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state <= 2'b01;\n\t\t\tend\n\t\tend\n\t\t2'b01: begin\n\t\t\tif (A == 1'b1) begin\n\t\t\t\tnext_state <= 2'b00;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state <= 2'b10;\n\t\t\tend\n\t\tend\n\t\t2'b10: begin\n\t\t\tif (A == 1'b1) begin\n\t\t\t\tnext_state <= 2'b01;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state <= 2'b11;\n\t\t\tend\n\t\tend\n\t\t2'b11: begin\n\t\t\tif (A == 1'b1) begin\n\t\t\t\tnext_state <= 2'b10;\n\t\t\tend\n\t\t\telse begin\n\t\t\t\tnext_state <= 2'b00;\n\t\t\tend\n\t\tend\n\t\tdefault: begin\n\t\t\tnext_state <= 2'b00;\n\t\tend\n\tendcase\nend\n \n//状态机第三段，结果输出，时序逻辑\nalways @(posedge clk or negedge rst_n) begin\n\tif (!rst_n) begin\n\t\tY_reg <= 1'b0;\n\tend\n\telse if (next_state == 2'b11) begin\n\t\tY_reg <= 1'b1;\n\tend\n\telse begin\n\t\tY_reg <= 1'b0;\n\tend\nend\n \nassign Y = Y_reg;\n \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Signal Declarations\n    reg  clk;\n    reg  rst_n;\n    reg  A;\n    wire Y;\n\n    // Instantiate the DUT (Device Under Test)\n    top inst_seq (\n        .clk(clk),\n        .rst_n(rst_n),\n        .A(A),\n        .Y(Y)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        clk = 1'b1;  // Initialize clock\n        rst_n = 1'b0; // Assert reset\n        #20 rst_n = 1'b1; // Deassert reset after 20 time units\n        #200 $finish;  // End simulation after 200 time units\n    end\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units\n\n    // Generate Random Input Signal\n    always #10 A = {$random} % 2;  // Generate random 1-bit value for A\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGA_8", "task_recommend": "Register-Transfer Level Shift Register.This example is a register-transfer level version of the gate-level shift register.\n\n#### Design Requirements:\n\n- **Implement a shift register:** A data value is shifted in on every clock cycle, on the rising edge, and the oldest value is shifted out. The shift register is FIFO. The shifted-out value is available after the falling edge of the clock.\n- **Depth of the shift register:** 4 bits.\n- **Module ports:**\n  - Data input (1 bit)\n  - Clock (1 bit)\n  - Data output (1 bit)", "images": ["MGA_8\\img_106.png"], "verilog": "module shift4 (dataIn, clk, dataOut);\n    output dataOut;\n    input dataIn, clk;\n    reg dataOut;\n    reg [2:0] shiftreg;\n\n    always @(posedge clk)\n        {dataOut, shiftreg} = @(negedge clk) {shiftreg, dataIn};\nendmodule\n\n    \nmodule clkGen (clk);\n    parameter period = 2;\n    output clk;\n    reg clk;\n    \n    initial clk = 0;                // start off with 0\n    always                          // clock loop\n        #(period/2) clk = ~clk;\nendmodule\nmodule shiftTest (dataBit, delayedBit, clk);\n    output dataBit;\n    input delayedBit;\n    input clk;\n    reg dataBit;\n    \n    task emitBits;  // helper task to emit n bits\n        input [7:0] bits, n;    // task inputs\n        begin\n            repeat (n) begin    // assume clk is at negedge\n                    dataBit = bits[0];  // take just the low order bit\n                    bits = bits >> 1;\n                @(negedge clk) ;    \n            end                 // leave at negative edge\n        end\n    endtask\n        \n    always @(posedge clk)       // display results\n        $strobe($stime,\" dataBit: %b delayedBit: %b\", dataBit, delayedBit);\n            \n    initial begin               // produce test data\n        emitBits(0, 1);         // take care of first cycle\n        emitBits('b10010, 5);\n        emitBits('b101101, 6);\n        emitBits('b01, 2);\n        emitBits(8'b00000010, 8);\n        $finish;\n    end\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    wire dataIn, dataOut, clk;\n\n    // Instantiate the 4-bit Shift Register (Device Under Test)\n    shift4 s4 (\n        .dataIn(dataIn),\n        .clk(clk),\n        .dataOut(dataOut)\n    );\n\n    // Instantiate the Clock Generator\n    clkGen #(10) cg (\n        .clk(clk)\n    );  // Generate a clock with a period of 10 time units\n\n    // Instantiate the Test Generator\n    top at (\n        .dataIn(dataIn),\n        .dataOut(dataOut),\n        .clk(clk)\n    );\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n\n"}
{"task_id": "MGP_1", "task_recommend": "Complete the following module so that clk has the following waveform.", "images": ["MGP_1\\img_92.png"], "verilog": "module clkgen (clk);\n\toutput clk;\n\treg clk;\ninitial begin\n\tclk = 0;\n#1\tforever begin\n\t#4\tclk = 1;\n\t#1\tclk = 0;\n\tend\nend\nendmodule\t", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declaration\n    wire clk1;\n\n    // Instantiate the Clock Generator\n    top c1 (\n        .clk(clk1)\n    );\n\n    // Monitor and Finish Simulation\n    initial begin\n        $monitor(\"Time = %0t | clk1 = %b\", $time, clk1); // Monitor changes in clk1\n        #30 $finish;  // End simulation after 30 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_2", "task_recommend": "Create a module with one input and one output that behaves like a wire.", "images": ["MGP_2\\img.png"], "verilog": "module top_module( input in, output out );\n    assign out = in;\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg in;\n    wire out;\n\n    // Instantiate the DUT (Device Under Test)\n    top uut (\n        .in(in),\n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        $monitor(\"Time = %0t: in = %b, out = %b\", $time, in, out); // Monitor changes in in and out\n        in = 0;  // Initial value of input\n        #10;     // Wait for 10 ns\n        in = 1;  // Change input to 1\n        #10;     // Wait for 10 ns\n        in = 0;  // Change input back to 0\n        #10;     // Wait for 10 ns\n        $finish; // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_3", "task_recommend": "Create a module with 3 inputs and 4 outputs that behaves like wires that makes these connections:\n\n- a -> w\n- b -> x\n- b -> y\n- c -> z", "images": ["MGP_3\\img_1.png"], "verilog": "module top_module( \n    input a,b,c,\n    output w,x,y,z );\n    assign w = a;\n    assign x = b,y = b;\n    assign z = c;\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg a, b, c;\n    wire w, x, y, z;\n\n    // Instantiate the DUT (Device Under Test)\n    top uut (\n        .a(a), .b(b), .c(c),\n        .w(w), .x(x), .y(y), .z(z)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        $monitor(\"Time = %0t: a = %b, b = %b, c = %b, w = %b, x = %b, y = %b, z = %b\",\n                 $time, a, b, c, w, x, y, z);\n\n        // Apply all possible combinations of inputs\n        a = 0; b = 0; c = 0; #10;  // 000\n        a = 0; b = 0; c = 1; #10;  // 001\n        a = 0; b = 1; c = 0; #10;  // 010\n        a = 0; b = 1; c = 1; #10;  // 011\n        a = 1; b = 0; c = 0; #10;  // 100\n        a = 1; b = 0; c = 1; #10;  // 101\n        a = 1; b = 1; c = 0; #10;  // 110\n        a = 1; b = 1; c = 1; #10;  // 111\n\n        $finish; // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_4", "task_recommend": "Complete the following module named clkgen is defined to generate two clock signals, clka and clkb. The two clock signals have the same frequency, but their phase difference causes them to stagger in time so that \"clka\" and \"clkb\" have the following waveforms.", "images": ["MGP_4\\img_105.png"], "verilog": "module clkgen (clka, clkb);\n\toutput clka, clkb;\n\treg clka, clkb;\n\tinitial begin\n\t\tclka = 0; clkb = 0;\n\tend\n\tinitial\n\t#1\tforever begin\n\t#9\tclka = 1;\n\t#1\tclka = 0;\n\t\tend\n\tinitial\n\t#3\tforever begin\n\t#9\tclkb = 1;\n\t#1\tclkb = 0;\n\t\tend\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    wire clka, clkb;\n\n    // Instantiate the DUT (Device Under Test)\n    top uut (\n        .clka(clka),\n        .clkb(clkb)\n    );\n\n    // Monitor Outputs\n    initial begin\n        $monitor(\"Time = %0t: clka = %b, clkb = %b\", $time, clka, clkb); // Monitor clock signals\n        #100;  // Run simulation for 100 time units\n        $finish; // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_5", "task_recommend": "Create a module that implements an XNOR gate.", "images": ["MGP_5\\img_5.png"], "verilog": "module top_module( \n    input a, \n    input b, \n    output out );\n    //assign out = a ~^ b;a和b相同输出0，不同输出1\n    //assign out = a ^~ b;\n    assign out = ~(a ^ b);\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 0; // Initialize inputs to 0\n\n        $monitor(\"T=%t: a=%b, b=%b, out(xor)=%b\", $time, a, b, out);\n\n        // Apply random values to inputs\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random value to 'a'\n               b = $random; // Assign random value to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_6", "task_recommend": "Create a module that implements a NOR gate. A NOR gate is an OR gate with its output inverted. A NOR function needs two operators when written in Verilog.\n\nAn assign statement drives a wire (or \"net\", as it's more formally called) with a value. This value can be as complex a function as you want, as long as it's a combinational (i.e., memory-less, with no hidden state) function. An assign statement is a continuous assignment because the output is \"recomputed\" whenever any of its inputs change, forever, much like a simple logic gate.", "images": ["MGP_6\\img_4.png"], "verilog": "module top_module( \n    input a, \n    input b, \n    output out );\n    assign out = ~(a | b);\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 0; // Initialize inputs to 0\n\n        $monitor(\"T=%t: a=%b, b=%b, out(nor)=%b\", $time, a, b, out);\n\n        // Apply random values to inputs\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random value to 'a'\n               b = $random; // Assign random value to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_7", "task_recommend": "A two-input logic gate consists of AND gates and NOT gates, please write the correct logic gate code according to the following picture:", "images": ["MGP_7\\img_31.png"], "verilog": "module top_module (\n    input a,\n    input b,\n    output out);\n    assign out = a & (~b);\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg a, b;\n    wire out;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b), \n        .out(out)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        {a, b} = 0; // Initialize inputs to 0\n\n        $monitor(\"T=%t: a=%b, b=%b, out(ano)=%b\", $time, a, b, out);\n\n        // Apply random values to inputs\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random value to 'a'\n               b = $random; // Assign random value to 'b'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGP_8", "task_recommend": "Implement a buffer as wire according to the following figure:", "images": ["MGP_8\\img_28.png"], "verilog": "module gates (\n    input a,\n    output b);\n    assign a = b;\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg a;\n    wire b;\n    integer i;\n\n    // Instantiate the DUT (Device Under Test)\n    top u0 (\n        .a(a), \n        .b(b)\n    );\n\n    // Testbench Stimulus\n    initial begin\n        a = 0; // Initialize input to 0\n\n        $monitor(\"T=%t: a=%b, b(wire)=%b\", $time, a, b);\n\n        // Apply random values to input\n        for (i = 0; i < 10; i = i + 1) begin\n            #1 a = $random; // Assign random value to 'a'\n        end\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_1", "task_recommend": "Write a state machine whose output is 1 every time it has seen its input be 1 for 3 consecutive cycles. The header for module run3 is shown to get you started. A sample input and output waveform is:", "images": ["MGS_1\\img_93.png"], "verilog": "module run3 (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg [1:0] count;\n\n\tassign out = count == 3;\n\n\tinitial count = 0;\n\t\n\talways @(posedge clk)\n\t\tcase (count)\n\t0:\t\tcount <= in;\n\t1:\t\tcount <= in ? 2 : 0;\n\t2:\t\tcount <= in ? 3 : 0;\n\t3:\t\tcount <= in ? 3 : 0;\n\t\tendcase\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    wire out;\n    reg in, clk;\n    integer cnt;\n\n    // Instantiate the DUT (Device Under Test)\n    top r3 (\n        .out(out), \n        .in(in), \n        .clk(clk)\n    );\n\n    // Clock Generation\n    initial begin\n        in = 0;       // Initialize input signal\n        clk = 0;      // Initialize clock\n        cnt = 0;      // Initialize counter\n        forever #5 clk = ~clk;  // Toggle clock every 5 time units\n    end\n\n    // Counter to track clock cycles\n    always @(posedge clk) \n        cnt = cnt + 1;\n\n    // Testbench Stimulus\n    initial begin\n        $monitor($stime, \"cycle: %d  in: %b  out: %b\", cnt, in, out);\n\n        #2 in = 1; // Set input to 1\n        repeat (3) @(posedge clk); // Wait for 3 clock cycles\n        in <= 0; // Set input to 0\n        repeat (1) @(posedge clk); // Wait for 1 clock cycle\n        in <= 1; // Set input to 1\n        repeat (4) @(posedge clk); // Wait for 4 clock cycles\n        in <= 0; // Set input to 0\n        repeat (2) @(posedge clk); // Wait for 2 clock cycles\n        #1 $finish; // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_2", "task_recommend": "Defines a JK flip-flop, where `j` and `k` are the inputs, `clk` is the clock signal, and `q` is the output. The behavior of the JK flip-flop changes with the clock's rising edge, as specified by different combinations of `j` and `k`:\n- **00**: The output `q` remains the same.\n- **01**: The output `q` is set to 0.\n- **10**: The output `q` is set to 1.\n- **11**: The output `q` toggles (i.e., if it was 0, it becomes 1, and vice versa).", "images": ["MGS_2\\img_94.png"], "verilog": "module jk_ff ( input j,\n               input k,\n               input clk,\n               output q);\n\n    reg q;\n\n    always @ (posedge clk)\n        case ({j,k})\n            2'b00 : q <= q;\n            2'b01 : q <= 0;\n            2'b10 : q <= 1;\n            2'b11 : q <= ~q;\n        endcase\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg j, k, clk;\n    wire q;\n\n    // Instantiate the DUT (Device Under Test)\n    top jk0 (\n        .j(j),\n        .k(k),\n        .clk(clk),\n        .q(q)\n    );\n\n    // Clock Generation\n    initial begin\n        clk = 0;\n        forever #5 clk = ~clk;  // Generate a clock with a period of 10 time units\n    end\n\n    // Testbench Stimulus\n    initial begin\n        j = 0;\n        k = 0;\n        #5 j = 0; k = 1;  // Test case: J=0, K=1\n        #20 j = 1; k = 0; // Test case: J=1, K=0\n        #20 j = 1; k = 1; // Test case: J=1, K=1\n        #20 $finish;      // End simulation\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_3", "task_recommend": "This module defines a D-type flip-flop with asynchronous reset:\n- **Inputs**: `d` (data input), `rstn` (active low reset), and `clk` (clock).\n- **Output**: `q` (output).", "images": ["MGS_3\\img_95.png"], "verilog": "module dff ( input d,\n             input rstn,\n             input clk,\n             output reg q);\n    always @ (posedge clk or negedge rstn)\n        if (!rstn)\n            q <= 0;\n        else\n            q <= d;\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk, d, rstn;\n    reg [2:0] delay;\n    wire q;\n\n    // Instantiate the DUT (Device Under Test)\n    top dff0 (\n        .d(d),\n        .rstn(rstn),\n        .clk(clk),\n        .q(q)\n    );\n\n    // Generate clock\n    initial begin\n        clk = 0;\n        forever #10 clk = ~clk;  // Toggle clock every 10 time units\n    end\n\n    // Testcase\n    initial begin\n        d = 0;\n        rstn = 0;  // Initialize reset to active low\n\n        #15 d = 1;  // Set d to 1 after 15 time units\n        #10 rstn = 1;  // Deassert reset after 10 more time units\n\n        for (integer i = 0; i < 5; i = i + 1) begin\n            delay = $random % 8;  // Random delay (up to 7 time units)\n            #(delay) d = i % 2;  // Assign d to alternate between 0 and 1\n        end\n\n        #50 $finish;  // End the simulation after 50 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_4", "task_recommend": "This module defines a D-type flip-flop with sync active-low reset.", "images": ["MGS_4\\img_96.png"], "verilog": "module dff (\n    input d, rstn, clk,\n    output reg q\n);\n\nalways @(posedge clk) begin\n    if (!rstn)\n        q <= 0;\n    else\n        q <= d;\nend\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk, d, rstn;\n    reg [2:0] delay;\n    wire q;\n\n    // Instantiate the DUT (Device Under Test)\n    top dff0 (\n        .d(d),\n        .rstn(rstn),\n        .clk(clk),\n        .q(q)\n    );\n\n    // Generate clock\n    initial begin\n        clk = 0;\n        forever #10 clk = ~clk;  // Toggle clock every 10 time units\n    end\n\n    // Testcase\n    initial begin\n        d = 0;\n        rstn = 0;  // Initialize reset to active low\n\n        #15 d = 1;  // Set d to 1 after 15 time units\n        #10 rstn = 1;  // Deassert reset after 10 more time units\n\n        // Generate random delays and test input\n        for (integer i = 0; i < 5; i = i + 1) begin\n            delay = $random % 8;  // Generate a random delay between 0 and 7\n            #(delay) d = i % 2;  // Assign alternating values of 0 and 1 to d\n        end\n\n        #50 $finish;  // End the simulation after additional 50 time units\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_5", "task_recommend": "Defines a D latch with an enable (en) and an active-low reset (rstn). The output q follows the input d whenever en is high, unless rstn is asserted, in which case q is reset to 0.", "images": ["MGS_5\\img_97.png"], "verilog": "module d_latch ( input d,            // 1-bit input pin for data\n                 input en,           // 1-bit input pin for enabling the latch\n                 input rstn,         // 1-bit input pin for active-low reset\n                 output reg q);      // 1-bit output pin for data output\n\n    // This always block is \"always\" triggered whenever en/rstn/d changes\n    // If reset is asserted then output will be zero\n    // Else as long as enable is high, output q follows input d\n    always @ (en or rstn or d)\n        if (!rstn)\n            q <= 0;\n        else if (en)\n            q <= d;\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb();\n    // Declare variables that can be used to drive values to the design\n    reg d;\n    reg en;\n    reg rstn;\n    reg [2:0] delay;\n    reg [1:0] delay2;\n    wire q; // Missing declaration of wire q\n\n    // Instantiate design and connect design ports with TB signals\n    top dl0 (\n        .d(d),\n        .en(en),\n        .rstn(rstn),\n        .q(q)\n    );\n\n    // This initial block forms the stimulus to test the design\n    initial begin\n        $monitor(\"T=%t en=%b d=%b q=%b\", $time, en, d, q);\n\n        // 1. Initialize testbench variables\n        d = 0;\n        en = 0;\n        rstn = 0;\n\n        // 2. Release reset\n        #10 rstn = 1;\n\n        // 3. Randomly change d and enable\n        for (integer i = 0; i < 5; i = i + 1) begin\n            delay2 = $random % 20; // Limit random delay to a reasonable range\n            #(delay2) en = ~en;   // Toggle enable with a random delay\n            delay = $random % 20; // Limit random delay to a reasonable range\n            #(delay) d = i[0];    // Use only one bit for d to match the input width\n        end\n\n        // Finish the simulation after the loop\n        #20 $finish; // Ensure enough time to observe last state changes\n    end\n\n    // VCD Dump for waveform analysis\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_6", "task_recommend": "4-bit Counter Operation\n- **Initialization and Counting**: The counter starts at `4'b0000` and increments by 1 for each clock cycle.\n- **Maximum and Rollover**: Upon reaching the maximum value `4'b1111`, the next increment causes it to roll over back to `4'b0000`.\n- **Continuation**: This cycle of counting from `4'b0000` to `4'b1111` and rolling over repeats as long as the counter is powered and receives a running clock signal while the reset is held high (inactive).\n- **Overflow**: When the counter is at `4'b1111` and receives another increment command, it attempts to reach `5'b10000`, but since only 4 bits are supported, the most significant bit (MSB) is discarded, resulting in the counter rolling over to `4'b0000`.", "images": ["MGS_6\\img_98.png"], "verilog": "module counter (\n    input clk,          // Declare input port for clock to allow the counter to count\n    input rstn,         // Declare input port for reset to allow the counter to be reset\n    output reg[3:0] out // Declare 4-bit output port to get the counter values\n);\n\n// This always block will be triggered at the rising edge of clk\n// Once inside this block, it checks if the reset is 0, if yes then change out to zero\n// If reset is 1, then design should be allowed to count up, so increment counter\nalways @(posedge clk) begin\n    if (!rstn)\n        out <= 0;\n    else\n        out <= out + 1;\nend\n\nendmodule", "test": "`timescale 1ns/1ps\n\nmodule tb;\n    reg clk;             // Clock signal for driving the counter\n    reg rstn;            // Active-low reset signal\n    wire [3:0] out;      // 4-bit output wire to capture counter output\n\n    // Instantiate the counter module\n    top c0 (\n        .clk(clk), \n        .rstn(rstn), \n        .out(out)\n    );\n\n    // Clock generation: Toggle clock every 5 ns to create a 10 ns period (100 MHz frequency)\n    initial begin\n        clk = 0;  // Initialize clock signal\n        forever #5 clk = ~clk;  // Toggle clock every 5 ns\n    end\n\n    // Stimulus to test the counter module\n    initial begin\n        // Initialize testbench variables\n        rstn = 0;  // Reset is asserted (active low)\n        \n        // Drive reset and stimulus\n        #20 rstn = 1;  // Release reset after 20 ns\n        #80 rstn = 0;  // Assert reset after 80 ns\n        #50 rstn = 1;  // Release reset after 50 ns\n\n        // Finish the simulation after 200 ns\n        #50 $finish;\n    end\n\n    // VCD Dump for waveform analysis\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_7", "task_recommend": "Create a 4-to-1 multiplexer with the output defined as a wire type.\n#### Input Description:\n\nd1, d2, d3, d4, sel\n\nType: wire\n\n#### Output Description:\n\nOutput signal: mux_out\n\nType: wire\n\nState Transitions:\n- d0  11\n- d1  10\n- d2  01\n- d3  00\n\nSignal Description:\n\n\nWaveform Explanation:", "images": ["MGS_7\\img_7.png", "MGS_7\\img_8.png"], "verilog": "`timescale 1ns/1ns\nmodule mux4_1(\ninput [1:0]d1,d2,d3,d0,\ninput [1:0]sel,\noutput[1:0]mux_out\n);\n    assign mux_out = sel[0]?(sel[1]?d0:d2):(sel[1]?d1:d3);\n    \nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Declare 2-bit data inputs and select lines\n    reg [1:0] d0, d1, d2, d3;\n    reg [1:0] sel;\n    wire [1:0] mux_out;\n\n    // Instantiate the 4-to-1 Multiplexer\n    top mux4_1_inst (\n        .d0(d0),\n        .d1(d1),\n        .d2(d2),\n        .d3(d3),\n        .sel(sel),\n        .mux_out(mux_out)\n    );\n\n    // Initial block to apply test vectors\n    initial begin\n        // Initialize data inputs\n        d0 = 2'd3;\n        d1 = 2'd0;\n        d2 = 2'd1;\n        d3 = 2'd2;\n\n        // Initialize select line\n        sel = 2'd0;\n\n        // Apply different select values with delays\n        #10 sel = 2'd1;\n        #10 sel = 2'd2;\n        #10 sel = 2'd3;\n        #10 sel = 2'd2;\n        #10 sel = 2'd0;\n        #10 sel = 2'd1;\n        #10 sel = 2'd3;\n\n        // Optionally, add more test cases or edge cases\n        #10 sel = 2'd0;\n        #10 sel = 2'd3;\n        #10 sel = 2'd1;\n\n        // Finish simulation\n        #10 $finish;\n    end\n\n    // Monitor changes in select and output\n    initial begin\n        $monitor(\"Time = %0t | sel = %b | mux_out = %b (Selected d%d)\",\n                 $time, sel, mux_out, sel);\n    end\n\n    // Dump waveform data for analysis\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
{"task_id": "MGS_8", "task_recommend": "This module `pr_en` selects one of four 8-bit inputs based on a 2-bit select signal.", "images": ["MGS_8\\img_102.png"], "verilog": "module pr_en (\n    input [7:0] a,\n    input [7:0] b,\n    input [7:0] c,\n    input [7:0] d,\n    input [1:0] sel,\n    output reg [7:0] out\n);\n\nalways @(a or b or c or d or sel) begin\n    if (sel == 2'b00)\n        out <= a;\n    else if (sel == 2'b01)\n        out <= b;\n    else if (sel == 2'b10)\n        out <= c;\n    else\n        out <= d;\nend\n\nendmodule", "test": "`timescale 1ns/1ns\n\nmodule tb;\n    // Declare 8-bit data inputs and select lines\n    reg [7:0] a, b, c, d;\n    reg [1:0] sel;\n    wire [7:0] out;\n    integer i;\n\n    // Instantiate the multiplexer\n    top pr_en0 (\n        .a(a),\n        .b(b),\n        .c(c),\n        .d(d),\n        .sel(sel),\n        .out(out)\n    );\n\n    // Initial block to apply test vectors\n    initial begin\n        // Initialize select signal and data inputs\n        sel = 2'd0;\n        a = 8'd0;\n        b = 8'd0;\n        c = 8'd0;\n        d = 8'd0;\n\n        // Assign random values to data inputs\n        a = $random;\n        b = $random;\n        c = $random;\n        d = $random;\n\n        // Print initial values\n        $monitor(\"Time = %0t | sel = %b | a = %b | b = %b | c = %b | d = %b | out = %b\", \n                 $time, sel, a, b, c, d, out);\n\n        // Cycle through each select signal value\n        for (i = 0; i < 4; i = i + 1) begin\n            #5 sel = i;\n        end\n\n        // Finish simulation after 20 time units\n        #5 $finish;\n    end\n\n    // Dump waveform data for analysis\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
