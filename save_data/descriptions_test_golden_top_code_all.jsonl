{"task_id": "GA_1", "task_recommend": "The module zero3 below implements a 3-stage pipeline. Each stage is a single bit, and there is a single bit as input. Modify this model to use the following pipe stage. Assume the clock period is 10. Click Answer to see a sample solution.", "verilog": "module zero3 (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg s1, s2, s3;\n\n\tassign out = s1==0 & s2==0 & s3==0;\n\n\tinitial begin\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\ts3 = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\ts1 <= in;\n\t\ts2 <= s1;\n\t\ts3 <= s2;\n\tend\nendmodule\n\n\n# module_top\nmodule top (out, in, clk);\n\toutput out;\n\tinput in, clk;\n\treg s1, s2, s3;\n\n\tassign out = s1==0 & s2==0 & s3==0;\n\n\tinitial begin\n\t\ts1 = 0;\n\t\ts2 = 0;\n\t\ts3 = 0;\n\tend\n\n\talways @(posedge clk) begin\n\t\ts1 <= in;\n\t\ts2 <= s1;\n\t\ts3 <= s2;\n\tend\nendmodule", "test": "module tb();\n\twire out;\n\treg in, clk;\n\n\ttop z3 (out, in, clk);\n\n\tinitial begin\n\t\tin = 0;\n\t\tclk = 0;\n\t\tforever #5 clk = ~clk;\n\tend\n\n\tinitial begin\n\t\t$monitor($stime,,\"clk: %b  in: %b  out: %b\", clk, in, out);\n\t\trepeat (2) @(posedge clk);\n\t\tin <= 1;\n\t\trepeat (2) @(posedge clk);\n\t\tin <= 0;\n\t\trepeat (4) @(posedge clk) ;\n\t\tin <= 1;\n\t\trepeat (3) @(posedge clk) in <= ~in;\n\t\t@(posedge clk) in <= 0;\n\t\trepeat (4) @(posedge clk) ;\n\t#1\t$finish;\n\t\n\tend\nendmodule"}
{"task_id": "MGA_1", "task_recommend": "This module implements a 4-bit ripple counter using the dff flip-flop described above. Each flip-flop captures the inverted output of the previous stage's output, creating a ripple effect through the counter.", "images": ["MGA_1\\img_99.png"], "verilog": "module dff (\n    input d,\n    input clk,\n    input rstn,\n    output reg q,\n    output qn\n);\nalways @(posedge clk or negedge rstn) begin\n    if (!rstn)\n        q <= 0;\n    else\n        q <= d;\nend\nassign qn = ~q;\nendmodule\n\nmodule ripple (\n    input clk,\n    input rstn,\n    output [3:0] out\n);\nwire q0, qn0;\nwire q1, qn1;\nwire q2, qn2;\nwire q3, qn3;\n\ndff dff0 (.d(qn0), .clk(clk), .rstn(rstn), .q(q0), .qn(qn0));\ndff dff1 (.d(qn1), .clk(q0), .rstn(rstn), .q(q1), .qn(qn1));\ndff dff2 (.d(qn2), .clk(q1), .rstn(rstn), .q(q2), .qn(qn2));\ndff dff3 (.d(qn3), .clk(q2), .rstn(rstn), .q(q3), .qn(qn3));\n\nassign out = {qn3, qn2, qn1, qn0};\nendmodule", "test": "`timescale 1ns / 1ps\n\nmodule tb;\n    // Signal Declarations\n    reg clk;\n    reg rstn;\n    wire [3:0] out;\n\n    // Instantiate the ripple counter (Device Under Test)\n    top r0 (\n        .clk(clk), \n        .rstn(rstn), \n        .out(out)\n    );\n\n    // Clock Generation\n    always #5 clk = ~clk;  // Toggle clock every 5 time units, creating a period of 10 time units\n\n    // Testbench Stimulus\n    initial begin\n        clk = 0;   // Initialize clock\n        rstn = 0;  // Assert reset\n\n        // De-assert reset after 4 clock cycles\n        repeat (4) @(posedge clk);\n        rstn <= 1;\n\n        // Run for 25 clock cycles before finishing simulation\n        repeat (25) @(posedge clk);\n        $finish;\n    end\n\n    // VCD Dump for Waveform Viewing\n    initial begin\n        $dumpfile(\"tb.vcd\");\n        $dumpvars(0, tb);\n    end\nendmodule\n"}
